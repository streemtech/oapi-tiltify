// Package tiltifyApi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package tiltifyApi

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/labstack/echo/v4"
)

// error response body. Only included in Post and Patch requests.
type Error struct {
	// An object describing the error that occurred
	Error *struct {
		Detial *string `json:"detial,omitempty"`
		Title  *string `json:"title,omitempty"`
	} `json:"error,omitempty"`

	// An object pointing to fields that are incorrect in a submitted model
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// This is the HTTP status code that is also sent with the request
	Meta *Meta `json:"meta,omitempty"`
}

// Image defines model for Image.
type Image struct {
	Alt    *string `json:"alt,omitempty"`
	Height *int    `json:"height,omitempty"`
	Src    *string `json:"src,omitempty"`
	Width  *int    `json:"width,omitempty"`
}

// Livestream defines model for Livestream.
type Livestream struct {
	Channel *string `json:"channel,omitempty"`
	Type    *string `json:"type,omitempty"`
}

// This is the HTTP status code that is also sent with the request
type Meta struct {
	Status *int `json:"status,omitempty"`
}

// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
type Pagination struct {
	First *string `json:"first,omitempty"`
	Last  *string `json:"last,omitempty"`
	Next  string  `json:"next"`
	Prev  string  `json:"prev"`
	Self  string  `json:"self"`
}

// Social defines model for Social.
type Social struct {
	Discord   *string `json:"discord,omitempty"`
	Facebook  *string `json:"facebook,omitempty"`
	Instagram *string `json:"instagram,omitempty"`
	Mixer     *string `json:"mixer,omitempty"`
	Twitch    *string `json:"twitch,omitempty"`
	Twitter   *string `json:"twitter,omitempty"`
	Website   *string `json:"website,omitempty"`
	Youtube   *string `json:"youtube,omitempty"`
}

// error response body. Only included in Post and Patch requests.
type BadRequest Error

// error response body. Only included in Post and Patch requests.
type Forbidden Error

// error response body. Only included in Post and Patch requests.
type NotAuthorized Error

// error response body. Only included in Post and Patch requests.
type NotFound Error

// error response body. Only included in Post and Patch requests.
type ServerError Error

// error response body. Only included in Post and Patch requests.
type Unprocessable Error

// GetCampaignsIdChallengesParams defines parameters for GetCampaignsIdChallenges.
type GetCampaignsIdChallengesParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCampaignsIdDonationsParams defines parameters for GetCampaignsIdDonations.
type GetCampaignsIdDonationsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCampaignsIdPollsParams defines parameters for GetCampaignsIdPolls.
type GetCampaignsIdPollsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCampaignsIdRewardsParams defines parameters for GetCampaignsIdRewards.
type GetCampaignsIdRewardsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCampaignsIdScheduleParams defines parameters for GetCampaignsIdSchedule.
type GetCampaignsIdScheduleParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCampaignsIdSupportingCampaignsParams defines parameters for GetCampaignsIdSupportingCampaigns.
type GetCampaignsIdSupportingCampaignsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCausesIdCampaignsParams defines parameters for GetCausesIdCampaigns.
type GetCausesIdCampaignsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCausesIdFundraisingEventsParams defines parameters for GetCausesIdFundraisingEvents.
type GetCausesIdFundraisingEventsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetCausesIdVisibilityOptionsParams defines parameters for GetCausesIdVisibilityOptions.
type GetCausesIdVisibilityOptionsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsParams defines parameters for GetFundraisingEvents.
type GetFundraisingEventsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsIdCampaignsParams defines parameters for GetFundraisingEventsIdCampaigns.
type GetFundraisingEventsIdCampaignsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsIdIncentivesParams defines parameters for GetFundraisingEventsIdIncentives.
type GetFundraisingEventsIdIncentivesParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsIdLeaderboardsParams defines parameters for GetFundraisingEventsIdLeaderboards.
type GetFundraisingEventsIdLeaderboardsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsIdRegistrationFieldsParams defines parameters for GetFundraisingEventsIdRegistrationFields.
type GetFundraisingEventsIdRegistrationFieldsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsIdRegistrationsParams defines parameters for GetFundraisingEventsIdRegistrations.
type GetFundraisingEventsIdRegistrationsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsIdScheduleParams defines parameters for GetFundraisingEventsIdSchedule.
type GetFundraisingEventsIdScheduleParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetFundraisingEventsIdVisibilityOptionsParams defines parameters for GetFundraisingEventsIdVisibilityOptions.
type GetFundraisingEventsIdVisibilityOptionsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetTeamsIdCampaignsParams defines parameters for GetTeamsIdCampaigns.
type GetTeamsIdCampaignsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetUsersIdCampaignsParams defines parameters for GetUsersIdCampaigns.
type GetUsersIdCampaignsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetUsersIdOwnedTeamsParams defines parameters for GetUsersIdOwnedTeams.
type GetUsersIdOwnedTeamsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// GetUsersIdTeamsParams defines parameters for GetUsersIdTeams.
type GetUsersIdTeamsParams struct {
	// This is the amount of results to return for the page. This number must be between 1 and 100. Used in Pagination.
	Count *int `json:"count,omitempty"`

	// Used in Pagination.
	Before *int `json:"before,omitempty"`

	// Used in Pagination.
	After *int `json:"after,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCampaignsId request
	GetCampaignsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdChallenges request
	GetCampaignsIdChallenges(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdDonations request
	GetCampaignsIdDonations(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdPolls request
	GetCampaignsIdPolls(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdRewards request
	GetCampaignsIdRewards(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdSchedule request
	GetCampaignsIdSchedule(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdSupportingCampaigns request
	GetCampaignsIdSupportingCampaigns(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesId request
	GetCausesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdCampaigns request
	GetCausesIdCampaigns(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdFundraisingEvents request
	GetCausesIdFundraisingEvents(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdLeaderboards request
	GetCausesIdLeaderboards(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdPermissions request
	GetCausesIdPermissions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdVisibilityOptions request
	GetCausesIdVisibilityOptions(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchCausesIdVisibilityOptions request
	PatchCausesIdVisibilityOptions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEvents request
	GetFundraisingEvents(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsId request
	GetFundraisingEventsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdCampaigns request
	GetFundraisingEventsIdCampaigns(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdIncentives request
	GetFundraisingEventsIdIncentives(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdLeaderboards request
	GetFundraisingEventsIdLeaderboards(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdRegistrationFields request
	GetFundraisingEventsIdRegistrationFields(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdRegistrations request
	GetFundraisingEventsIdRegistrations(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdSchedule request
	GetFundraisingEventsIdSchedule(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdVisibilityOptions request
	GetFundraisingEventsIdVisibilityOptions(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsId request
	GetTeamsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsIdCampaigns request
	GetTeamsIdCampaigns(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsIdCampaignsCid request
	GetTeamsIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersId request
	GetUsersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdCampaigns request
	GetUsersIdCampaigns(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdCampaignsCid request
	GetUsersIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdOwnedTeams request
	GetUsersIdOwnedTeams(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdTeams request
	GetUsersIdTeams(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCampaignsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdChallenges(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdChallengesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdDonations(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdDonationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdPolls(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdPollsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdRewards(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdRewardsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdSchedule(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdSupportingCampaigns(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdSupportingCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdCampaigns(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdFundraisingEvents(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdFundraisingEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdLeaderboards(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdLeaderboardsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdPermissions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdPermissionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdVisibilityOptions(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdVisibilityOptionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchCausesIdVisibilityOptions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchCausesIdVisibilityOptionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEvents(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdCampaigns(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdIncentives(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdIncentivesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdLeaderboards(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdLeaderboardsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdRegistrationFields(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdRegistrationFieldsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdRegistrations(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdRegistrationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdSchedule(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdVisibilityOptions(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdVisibilityOptionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsIdCampaigns(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdCampaignsCidRequest(c.Server, id, cid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdCampaigns(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdCampaignsCidRequest(c.Server, id, cid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdOwnedTeams(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdOwnedTeamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdTeams(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdTeamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCampaignsIdRequest generates requests for GetCampaignsId
func NewGetCampaignsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdChallengesRequest generates requests for GetCampaignsIdChallenges
func NewGetCampaignsIdChallengesRequest(server string, id int, params *GetCampaignsIdChallengesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/challenges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdDonationsRequest generates requests for GetCampaignsIdDonations
func NewGetCampaignsIdDonationsRequest(server string, id int, params *GetCampaignsIdDonationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/donations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdPollsRequest generates requests for GetCampaignsIdPolls
func NewGetCampaignsIdPollsRequest(server string, id int, params *GetCampaignsIdPollsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/polls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdRewardsRequest generates requests for GetCampaignsIdRewards
func NewGetCampaignsIdRewardsRequest(server string, id int, params *GetCampaignsIdRewardsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/rewards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdScheduleRequest generates requests for GetCampaignsIdSchedule
func NewGetCampaignsIdScheduleRequest(server string, id int, params *GetCampaignsIdScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdSupportingCampaignsRequest generates requests for GetCampaignsIdSupportingCampaigns
func NewGetCampaignsIdSupportingCampaignsRequest(server string, id int, params *GetCampaignsIdSupportingCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/supporting-campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdRequest generates requests for GetCausesId
func NewGetCausesIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdCampaignsRequest generates requests for GetCausesIdCampaigns
func NewGetCausesIdCampaignsRequest(server string, id int, params *GetCausesIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdFundraisingEventsRequest generates requests for GetCausesIdFundraisingEvents
func NewGetCausesIdFundraisingEventsRequest(server string, id int, params *GetCausesIdFundraisingEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/fundraising-events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdLeaderboardsRequest generates requests for GetCausesIdLeaderboards
func NewGetCausesIdLeaderboardsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/leaderboards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdPermissionsRequest generates requests for GetCausesIdPermissions
func NewGetCausesIdPermissionsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdVisibilityOptionsRequest generates requests for GetCausesIdVisibilityOptions
func NewGetCausesIdVisibilityOptionsRequest(server string, id int, params *GetCausesIdVisibilityOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/visibility-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchCausesIdVisibilityOptionsRequest generates requests for PatchCausesIdVisibilityOptions
func NewPatchCausesIdVisibilityOptionsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/visibility-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsRequest generates requests for GetFundraisingEvents
func NewGetFundraisingEventsRequest(server string, params *GetFundraisingEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdRequest generates requests for GetFundraisingEventsId
func NewGetFundraisingEventsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdCampaignsRequest generates requests for GetFundraisingEventsIdCampaigns
func NewGetFundraisingEventsIdCampaignsRequest(server string, id int, params *GetFundraisingEventsIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdIncentivesRequest generates requests for GetFundraisingEventsIdIncentives
func NewGetFundraisingEventsIdIncentivesRequest(server string, id int, params *GetFundraisingEventsIdIncentivesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/incentives", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdLeaderboardsRequest generates requests for GetFundraisingEventsIdLeaderboards
func NewGetFundraisingEventsIdLeaderboardsRequest(server string, id int, params *GetFundraisingEventsIdLeaderboardsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/leaderboards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdRegistrationFieldsRequest generates requests for GetFundraisingEventsIdRegistrationFields
func NewGetFundraisingEventsIdRegistrationFieldsRequest(server string, id int, params *GetFundraisingEventsIdRegistrationFieldsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/registration-fields", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdRegistrationsRequest generates requests for GetFundraisingEventsIdRegistrations
func NewGetFundraisingEventsIdRegistrationsRequest(server string, id int, params *GetFundraisingEventsIdRegistrationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/registrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdScheduleRequest generates requests for GetFundraisingEventsIdSchedule
func NewGetFundraisingEventsIdScheduleRequest(server string, id int, params *GetFundraisingEventsIdScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdVisibilityOptionsRequest generates requests for GetFundraisingEventsIdVisibilityOptions
func NewGetFundraisingEventsIdVisibilityOptionsRequest(server string, id int, params *GetFundraisingEventsIdVisibilityOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/visibility-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsIdRequest generates requests for GetTeamsId
func NewGetTeamsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsIdCampaignsRequest generates requests for GetTeamsIdCampaigns
func NewGetTeamsIdCampaignsRequest(server string, id int, params *GetTeamsIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsIdCampaignsCidRequest generates requests for GetTeamsIdCampaignsCid
func NewGetTeamsIdCampaignsCidRequest(server string, id int, cid int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cid", runtime.ParamLocationPath, cid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/campaigns/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdRequest generates requests for GetUsersId
func NewGetUsersIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdCampaignsRequest generates requests for GetUsersIdCampaigns
func NewGetUsersIdCampaignsRequest(server string, id int, params *GetUsersIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdCampaignsCidRequest generates requests for GetUsersIdCampaignsCid
func NewGetUsersIdCampaignsCidRequest(server string, id int, cid int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cid", runtime.ParamLocationPath, cid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/campaigns/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdOwnedTeamsRequest generates requests for GetUsersIdOwnedTeams
func NewGetUsersIdOwnedTeamsRequest(server string, id int, params *GetUsersIdOwnedTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/owned-teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdTeamsRequest generates requests for GetUsersIdTeams
func NewGetUsersIdTeamsRequest(server string, id int, params *GetUsersIdTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCampaignsId request
	GetCampaignsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCampaignsIdResponse, error)

	// GetCampaignsIdChallenges request
	GetCampaignsIdChallengesWithResponse(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdChallengesResponse, error)

	// GetCampaignsIdDonations request
	GetCampaignsIdDonationsWithResponse(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdDonationsResponse, error)

	// GetCampaignsIdPolls request
	GetCampaignsIdPollsWithResponse(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdPollsResponse, error)

	// GetCampaignsIdRewards request
	GetCampaignsIdRewardsWithResponse(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdRewardsResponse, error)

	// GetCampaignsIdSchedule request
	GetCampaignsIdScheduleWithResponse(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdScheduleResponse, error)

	// GetCampaignsIdSupportingCampaigns request
	GetCampaignsIdSupportingCampaignsWithResponse(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdSupportingCampaignsResponse, error)

	// GetCausesId request
	GetCausesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdResponse, error)

	// GetCausesIdCampaigns request
	GetCausesIdCampaignsWithResponse(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetCausesIdCampaignsResponse, error)

	// GetCausesIdFundraisingEvents request
	GetCausesIdFundraisingEventsWithResponse(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetCausesIdFundraisingEventsResponse, error)

	// GetCausesIdLeaderboards request
	GetCausesIdLeaderboardsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdLeaderboardsResponse, error)

	// GetCausesIdPermissions request
	GetCausesIdPermissionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdPermissionsResponse, error)

	// GetCausesIdVisibilityOptions request
	GetCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetCausesIdVisibilityOptionsResponse, error)

	// PatchCausesIdVisibilityOptions request
	PatchCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*PatchCausesIdVisibilityOptionsResponse, error)

	// GetFundraisingEvents request
	GetFundraisingEventsWithResponse(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsResponse, error)

	// GetFundraisingEventsId request
	GetFundraisingEventsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdResponse, error)

	// GetFundraisingEventsIdCampaigns request
	GetFundraisingEventsIdCampaignsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdCampaignsResponse, error)

	// GetFundraisingEventsIdIncentives request
	GetFundraisingEventsIdIncentivesWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdIncentivesResponse, error)

	// GetFundraisingEventsIdLeaderboards request
	GetFundraisingEventsIdLeaderboardsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdLeaderboardsResponse, error)

	// GetFundraisingEventsIdRegistrationFields request
	GetFundraisingEventsIdRegistrationFieldsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationFieldsResponse, error)

	// GetFundraisingEventsIdRegistrations request
	GetFundraisingEventsIdRegistrationsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationsResponse, error)

	// GetFundraisingEventsIdSchedule request
	GetFundraisingEventsIdScheduleWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdScheduleResponse, error)

	// GetFundraisingEventsIdVisibilityOptions request
	GetFundraisingEventsIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdVisibilityOptionsResponse, error)

	// GetTeams request
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// GetTeamsId request
	GetTeamsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamsIdResponse, error)

	// GetTeamsIdCampaigns request
	GetTeamsIdCampaignsWithResponse(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsResponse, error)

	// GetTeamsIdCampaignsCid request
	GetTeamsIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsCidResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// GetUsersId request
	GetUsersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error)

	// GetUsersIdCampaigns request
	GetUsersIdCampaignsWithResponse(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsResponse, error)

	// GetUsersIdCampaignsCid request
	GetUsersIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsCidResponse, error)

	// GetUsersIdOwnedTeams request
	GetUsersIdOwnedTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdOwnedTeamsResponse, error)

	// GetUsersIdTeams request
	GetUsersIdTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdTeamsResponse, error)
}

type GetCampaignsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AmountRaised           *int        `json:"amountRaised,omitempty"`
			Avatar                 *Image      `json:"avatar,omitempty"`
			CauseId                *int        `json:"causeId,omitempty"`
			Description            *string     `json:"description,omitempty"`
			EndsAt                 *int        `json:"endsAt,omitempty"`
			FundraiserGoalAmount   *int        `json:"fundraiserGoalAmount,omitempty"`
			FundraisingEventId     *int        `json:"fundraisingEventId,omitempty"`
			Id                     *int        `json:"id,omitempty"`
			Livestream             *Livestream `json:"livestream,omitempty"`
			Name                   *string     `json:"name,omitempty"`
			OriginalGoalAmount     *int        `json:"originalGoalAmount,omitempty"`
			Slug                   *string     `json:"slug,omitempty"`
			StartsAt               *int        `json:"startsAt,omitempty"`
			Status                 *string     `json:"status,omitempty"`
			Supportable            *bool       `json:"supportable,omitempty"`
			SupportingAmountRaised *int        `json:"supportingAmountRaised,omitempty"`
			Team                   *struct {
				Avatar   *Image  `json:"avatar,omitempty"`
				Id       *int    `json:"id,omitempty"`
				Slug     *string `json:"slug,omitempty"`
				Url      *string `json:"url,omitempty"`
				Username *string `json:"username,omitempty"`
			} `json:"team,omitempty"`
			TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
			Url               *string `json:"url,omitempty"`
			User              *struct {
				Avatar   *Image  `json:"avatar,omitempty"`
				Id       *int    `json:"id,omitempty"`
				Slug     *string `json:"slug,omitempty"`
				Url      *string `json:"url,omitempty"`
				Username *string `json:"username,omitempty"`
			} `json:"user,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdChallengesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			ActivatesOn       *int    `json:"activatesOn,omitempty"`
			Active            *bool   `json:"active,omitempty"`
			Amount            *int    `json:"amount,omitempty"`
			CampaignId        *int    `json:"campaignId,omitempty"`
			CreatedAt         *int    `json:"createdAt,omitempty"`
			EndsAt            *int    `json:"endsAt,omitempty"`
			Id                *int    `json:"id,omitempty"`
			Name              *string `json:"name,omitempty"`
			TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
			UpdatedAt         *int    `json:"updatedAt,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdChallengesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdChallengesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdDonationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Amount      *float32 `json:"amount,omitempty"`
			Comment     *string  `json:"comment,omitempty"`
			CompletedAt *int     `json:"completedAt,omitempty"`
			Id          *int     `json:"id,omitempty"`
			Name        *string  `json:"name,omitempty"`
			RewardId    *int     `json:"rewardId,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdDonationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdDonationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdPollsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Active     *bool   `json:"active,omitempty"`
			CampaignId *int    `json:"campaignId,omitempty"`
			CreatedAt  *int    `json:"createdAt,omitempty"`
			Id         *int    `json:"id,omitempty"`
			Name       *string `json:"name,omitempty"`
			Options    *[]struct {
				CreatedAt         *int    `json:"createdAt,omitempty"`
				Id                *int    `json:"id,omitempty"`
				Name              *string `json:"name,omitempty"`
				PollId            *int    `json:"pollId,omitempty"`
				TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
				UpdatedAt         *int    `json:"updatedAt,omitempty"`
			} `json:"options,omitempty"`
			UpdatedAt *int `json:"updatedAt,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdPollsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdPollsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdRewardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Active                  *bool                   `json:"active,omitempty"`
			Amount                  *int                    `json:"amount,omitempty"`
			CreatedAt               *int                    `json:"createdAt,omitempty"`
			Currency                *string                 `json:"currency,omitempty"`
			Description             *string                 `json:"description,omitempty"`
			FairMarketValue         *int                    `json:"fairMarketValue,omitempty"`
			Id                      *int                    `json:"id,omitempty"`
			Image                   *Image                  `json:"image,omitempty"`
			Kind                    *string                 `json:"kind,omitempty"`
			Name                    *string                 `json:"name,omitempty"`
			Quantity                *map[string]interface{} `json:"quantity,omitempty"`
			Remaining               *map[string]interface{} `json:"remaining,omitempty"`
			ShippingAddressRequired *bool                   `json:"shippingAddressRequired,omitempty"`
			ShippingNote            *map[string]interface{} `json:"shippingNote,omitempty"`
			StartsAt                *int                    `json:"startsAt,omitempty"`
			UpdatedAt               *int                    `json:"updatedAt,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdRewardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdRewardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Description *string `json:"description,omitempty"`
			Id          *int    `json:"id,omitempty"`
			Name        *string `json:"name,omitempty"`
			StartsAt    *int    `json:"startsAt,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdSupportingCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised       *int                    `json:"amountRaised,omitempty"`
			CauseId            *int                    `json:"causeId,omitempty"`
			Description        *string                 `json:"description,omitempty"`
			EndsOn             *string                 `json:"endsOn,omitempty"`
			FundraisingEventId *int                    `json:"fundraisingEventId,omitempty"`
			Goal               *int                    `json:"goal,omitempty"`
			Id                 *int                    `json:"id,omitempty"`
			Name               *string                 `json:"name,omitempty"`
			OriginalGoal       *int                    `json:"originalGoal,omitempty"`
			Slug               *string                 `json:"slug,omitempty"`
			StartsOn           *string                 `json:"startsOn,omitempty"`
			TeamId             *map[string]interface{} `json:"teamId,omitempty"`
			Thumbnail          *Image                  `json:"thumbnail,omitempty"`
			TotalAmountRaised  *int                    `json:"totalAmountRaised,omitempty"`
			Url                *string                 `json:"url,omitempty"`
			UserId             *int                    `json:"userId,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdSupportingCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdSupportingCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			About   *string `json:"about,omitempty"`
			Address *struct {
				AddressLine1 *string `json:"addressLine1,omitempty"`
				AddressLine2 *string `json:"addressLine2,omitempty"`
				City         *string `json:"city,omitempty"`
				Country      *string `json:"country,omitempty"`
				PostalCode   *string `json:"postalCode,omitempty"`
				Region       *string `json:"region,omitempty"`
			} `json:"address,omitempty"`
			Avatar             *Image  `json:"avatar,omitempty"`
			Banner             *Image  `json:"banner,omitempty"`
			ContactEmail       *string `json:"contactEmail,omitempty"`
			Currency           *string `json:"currency,omitempty"`
			Id                 *int    `json:"id,omitempty"`
			Image              *Image  `json:"image,omitempty"`
			LegalName          *string `json:"legalName,omitempty"`
			Logo               *Image  `json:"logo,omitempty"`
			MailchimpConnected *bool   `json:"mailchimpConnected,omitempty"`
			Name               *string `json:"name,omitempty"`
			PaypalCurrencyCode *string `json:"paypalCurrencyCode,omitempty"`
			PaypalEmail        *string `json:"paypalEmail,omitempty"`
			Settings           *struct {
				Colors *struct {
					Background *string `json:"background,omitempty"`
					Highlight  *string `json:"highlight,omitempty"`
				} `json:"colors,omitempty"`
				FindOutMoreLink *string `json:"findOutMoreLink,omitempty"`
				FooterCopyright *string `json:"footerCopyright,omitempty"`
				HeaderIntro     *string `json:"headerIntro,omitempty"`
				HeaderTitle     *string `json:"headerTitle,omitempty"`
			} `json:"settings,omitempty"`
			Slug            *string `json:"slug,omitempty"`
			Social          *Social `json:"social,omitempty"`
			Status          *string `json:"status,omitempty"`
			StripeConnected *bool   `json:"stripeConnected,omitempty"`
			Video           *string `json:"video,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised       *int                    `json:"amountRaised,omitempty"`
			CauseId            *int                    `json:"causeId,omitempty"`
			Currency           *string                 `json:"currency,omitempty"`
			Description        *string                 `json:"description,omitempty"`
			EndsOn             *string                 `json:"endsOn,omitempty"`
			FundraisingEventId *int                    `json:"fundraisingEventId,omitempty"`
			Goal               *int                    `json:"goal,omitempty"`
			Name               *string                 `json:"name,omitempty"`
			OriginalGoal       *int                    `json:"originalGoal,omitempty"`
			Slug               *string                 `json:"slug,omitempty"`
			StartsOn           *string                 `json:"startsOn,omitempty"`
			TeamId             *map[string]interface{} `json:"teamId,omitempty"`
			Thumbnail          *Image                  `json:"thumbnail,omitempty"`
			TotalAmountRaised  *int                    `json:"totalAmountRaised,omitempty"`
			Url                *string                 `json:"url,omitempty"`
			UserId             *int                    `json:"userId,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdFundraisingEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised *int    `json:"amountRaised,omitempty"`
			Avatar       *Image  `json:"avatar,omitempty"`
			Banner       *Image  `json:"banner,omitempty"`
			BannerIntro  *string `json:"bannerIntro,omitempty"`
			BannerTitle  *string `json:"bannerTitle,omitempty"`
			CauseId      *int    `json:"causeId,omitempty"`
			Currency     *string `json:"currency,omitempty"`
			Description  *string `json:"description,omitempty"`
			EndsOn       *string `json:"endsOn,omitempty"`
			Goal         *int    `json:"goal,omitempty"`
			Id           *int    `json:"id,omitempty"`
			Image        *Image  `json:"image,omitempty"`
			Logo         *Image  `json:"logo,omitempty"`
			Name         *string `json:"name,omitempty"`
			Slug         *string `json:"slug,omitempty"`
			StartsOn     *string `json:"startsOn,omitempty"`
			Url          *string `json:"url,omitempty"`
			Video        *Image  `json:"video,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdFundraisingEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdFundraisingEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdLeaderboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised *int    `json:"amountRaised,omitempty"`
			Avatar       *Image  `json:"avatar,omitempty"`
			Banner       *Image  `json:"banner,omitempty"`
			BannerIntro  *string `json:"bannerIntro,omitempty"`
			BannerTitle  *string `json:"bannerTitle,omitempty"`
			CauseId      *int    `json:"causeId,omitempty"`
			Currency     *string `json:"currency,omitempty"`
			Description  *string `json:"description,omitempty"`
			EndsOn       *string `json:"endsOn,omitempty"`
			Goal         *int    `json:"goal,omitempty"`
			Id           *int    `json:"id,omitempty"`
			Image        *Image  `json:"image,omitempty"`
			Logo         *Image  `json:"logo,omitempty"`
			Name         *string `json:"name,omitempty"`
			Slug         *string `json:"slug,omitempty"`
			StartsOn     *string `json:"startsOn,omitempty"`
			Url          *string `json:"url,omitempty"`
			Video        *Image  `json:"video,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdLeaderboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdLeaderboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Activated                               *bool `json:"activated,omitempty"`
			AdminApiEnabled                         *bool `json:"adminApiEnabled,omitempty"`
			AdminBrandingColors                     *bool `json:"adminBrandingColors,omitempty"`
			AdminBrandingDetails                    *bool `json:"adminBrandingDetails,omitempty"`
			AdminBrandingEnabled                    *bool `json:"adminBrandingEnabled,omitempty"`
			AdminBrandingImages                     *bool `json:"adminBrandingImages,omitempty"`
			AdminEnabled                            *bool `json:"adminEnabled,omitempty"`
			AdminFinanceEnabled                     *bool `json:"adminFinanceEnabled,omitempty"`
			AdminGeneralEnabled                     *bool `json:"adminGeneralEnabled,omitempty"`
			AdminIntegrationsEnabled                *bool `json:"adminIntegrationsEnabled,omitempty"`
			AdminVisibilityEnabled                  *bool `json:"adminVisibilityEnabled,omitempty"`
			CauseLeaderboard                        *bool `json:"causeLeaderboard,omitempty"`
			DashboardChart                          *bool `json:"dashboardChart,omitempty"`
			DashboardEnabled                        *bool `json:"dashboardEnabled,omitempty"`
			FundraisingEventsEnabled                *bool `json:"fundraisingEventsEnabled,omitempty"`
			FundraisingEventsGeneralColors          *bool `json:"fundraisingEventsGeneralColors,omitempty"`
			FundraisingEventsGeneralDetails         *bool `json:"fundraisingEventsGeneralDetails,omitempty"`
			FundraisingEventsGeneralEnabled         *bool `json:"fundraisingEventsGeneralEnabled,omitempty"`
			FundraisingEventsGeneralImages          *bool `json:"fundraisingEventsGeneralImages,omitempty"`
			FundraisingEventsIncentives             *bool `json:"fundraisingEventsIncentives,omitempty"`
			FundraisingEventsLeaderboard            *bool `json:"fundraisingEventsLeaderboard,omitempty"`
			FundraisingEventsRegistrationEnabled    *bool `json:"fundraisingEventsRegistrationEnabled,omitempty"`
			FundraisingEventsReporting              *bool `json:"fundraisingEventsReporting,omitempty"`
			FundraisingEventsReportingCampaigns     *bool `json:"fundraisingEventsReportingCampaigns,omitempty"`
			FundraisingEventsReportingDonations     *bool `json:"fundraisingEventsReportingDonations,omitempty"`
			FundraisingEventsReportingFundraisers   *bool `json:"fundraisingEventsReportingFundraisers,omitempty"`
			FundraisingEventsSchedule               *bool `json:"fundraisingEventsSchedule,omitempty"`
			FundraisingEventsVisibilityDetails      *bool `json:"fundraisingEventsVisibilityDetails,omitempty"`
			FundraisingEventsVisibilityEnabled      *bool `json:"fundraisingEventsVisibilityEnabled,omitempty"`
			FundraisingEventsVisibilityLeaderboards *bool `json:"fundraisingEventsVisibilityLeaderboards,omitempty"`
			ReportingCampaigns                      *bool `json:"reportingCampaigns,omitempty"`
			ReportingChart                          *bool `json:"reportingChart,omitempty"`
			ReportingDonations                      *bool `json:"reportingDonations,omitempty"`
			ReportingEnabled                        *bool `json:"reportingEnabled,omitempty"`
			ReportingFundraisers                    *bool `json:"reportingFundraisers,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdVisibilityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Donate *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"donate,omitempty"`
			DonorLeaderboard *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"donorLeaderboard,omitempty"`
			EndsAt *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"endsAt,omitempty"`
			FundraiserGoalAmount *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"fundraiserGoalAmount,omitempty"`
			IndividualLeaderboard *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"individualLeaderboard,omitempty"`
			PreventDonationsBeforeStart *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"preventDonationsBeforeStart,omitempty"`
			Registration *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"registration,omitempty"`
			StartsAt *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"startsAt,omitempty"`
			TeamLeaderboard *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"teamLeaderboard,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdVisibilityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdVisibilityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchCausesIdVisibilityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Donate *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"donate,omitempty"`
			DonorLeaderboard *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"donorLeaderboard,omitempty"`
			EndsAt *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"endsAt,omitempty"`
			FundraiserGoalAmount *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"fundraiserGoalAmount,omitempty"`
			IndividualLeaderboard *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"individualLeaderboard,omitempty"`
			PreventDonationsBeforeStart *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"preventDonationsBeforeStart,omitempty"`
			Registration *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"registration,omitempty"`
			StartsAt *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"startsAt,omitempty"`
			TeamLeaderboard *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"teamLeaderboard,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r PatchCausesIdVisibilityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchCausesIdVisibilityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised *int    `json:"amountRaised,omitempty"`
			Avatar       *Image  `json:"avatar,omitempty"`
			Banner       *Image  `json:"banner,omitempty"`
			BannerIntro  *string `json:"bannerIntro,omitempty"`
			BannerTitle  *string `json:"bannerTitle,omitempty"`
			CauseId      *int    `json:"causeId,omitempty"`
			Currency     *string `json:"currency,omitempty"`
			Description  *string `json:"description,omitempty"`
			EndsOn       *string `json:"endsOn,omitempty"`
			Goal         *int    `json:"goal,omitempty"`
			Id           *int    `json:"id,omitempty"`
			Image        *Image  `json:"image,omitempty"`
			Logo         *Image  `json:"logo,omitempty"`
			Name         *string `json:"name,omitempty"`
			Slug         *string `json:"slug,omitempty"`
			StartsOn     *string `json:"startsOn,omitempty"`
			Url          *string `json:"url,omitempty"`
			Video        *Image  `json:"video,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AmountRaised *int    `json:"amountRaised,omitempty"`
			Avatar       *Image  `json:"avatar,omitempty"`
			Banner       *Image  `json:"banner,omitempty"`
			BannerIntro  *string `json:"bannerIntro,omitempty"`
			BannerTitle  *string `json:"bannerTitle,omitempty"`
			CauseId      *int    `json:"causeId,omitempty"`
			Currency     *string `json:"currency,omitempty"`
			Description  *string `json:"description,omitempty"`
			EndsOn       *string `json:"endsOn,omitempty"`
			Goal         *int    `json:"goal,omitempty"`
			Id           *int    `json:"id,omitempty"`
			Image        *Image  `json:"image,omitempty"`
			Logo         *Image  `json:"logo,omitempty"`
			Name         *string `json:"name,omitempty"`
			Slug         *string `json:"slug,omitempty"`
			StartsOn     *string `json:"startsOn,omitempty"`
			Url          *string `json:"url,omitempty"`
			Video        *Image  `json:"video,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised       *int                    `json:"amountRaised,omitempty"`
			CauseId            *int                    `json:"causeId,omitempty"`
			Currency           *string                 `json:"currency,omitempty"`
			Description        *string                 `json:"description,omitempty"`
			EndsOn             *string                 `json:"endsOn,omitempty"`
			FundraisingEventId *int                    `json:"fundraisingEventId,omitempty"`
			Goal               *int                    `json:"goal,omitempty"`
			Name               *string                 `json:"name,omitempty"`
			OriginalGoal       *int                    `json:"originalGoal,omitempty"`
			Slug               *string                 `json:"slug,omitempty"`
			StartsOn           *string                 `json:"startsOn,omitempty"`
			TeamId             *map[string]interface{} `json:"teamId,omitempty"`
			Thumbnail          *Image                  `json:"thumbnail,omitempty"`
			TotalAmountRaised  *int                    `json:"totalAmountRaised,omitempty"`
			Url                *string                 `json:"url,omitempty"`
			UserId             *int                    `json:"userId,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdIncentivesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			CreatedAt   *int    `json:"createdAt,omitempty"`
			Description *string `json:"description,omitempty"`
			Id          *int    `json:"id,omitempty"`
			Image       *Image  `json:"image,omitempty"`
			Title       *string `json:"title,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdIncentivesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdIncentivesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdLeaderboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Individual *[]struct {
				AmountRaised *int    `json:"amount_raised,omitempty"`
				Name         *string `json:"name,omitempty"`
				Url          *string `json:"url,omitempty"`
				UserId       *int    `json:"userId,omitempty"`
			} `json:"individual,omitempty"`
			Team *[]struct {
				AmountRaised *int    `json:"amount_raised,omitempty"`
				Name         *string `json:"name,omitempty"`
				TeamId       *int    `json:"teamId,omitempty"`
				Url          *string `json:"url,omitempty"`
			} `json:"team,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdLeaderboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdLeaderboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdRegistrationFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Address *struct {
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"address,omitempty"`
			ServiceHours *struct {
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"service_hours,omitempty"`
			ShirtSize *struct {
				Enabled *bool `json:"enabled,omitempty"`
			} `json:"shirt_size,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdRegistrationFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdRegistrationFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdRegistrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Address *struct {
				AddressLine1 *string `json:"addressLine1,omitempty"`
				AddressLine2 *string `json:"addressLine2,omitempty"`
				City         *string `json:"city,omitempty"`
				PostalCode   *string `json:"postalCode,omitempty"`
				State        *string `json:"state,omitempty"`
			} `json:"address,omitempty"`
			Email        *string `json:"email,omitempty"`
			Id           *int    `json:"id,omitempty"`
			RegisteredAt *string `json:"registeredAt,omitempty"`
			ServiceHours *bool   `json:"serviceHours,omitempty"`
			ShirtSize    *string `json:"shirtSize,omitempty"`
			Subscribed   *bool   `json:"subscribed,omitempty"`
			UserId       *int    `json:"userId,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdRegistrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdRegistrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Description *string `json:"description,omitempty"`
			Id          *int    `json:"id,omitempty"`
			Name        *string `json:"name,omitempty"`
			StartsAt    *int    `json:"startsAt,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdVisibilityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Donate *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"donate,omitempty"`
			DonorLeaderboard *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"donorLeaderboard,omitempty"`
			EndsAt *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"endsAt,omitempty"`
			FundraiserGoalAmount *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"fundraiserGoalAmount,omitempty"`
			IndividualLeaderboard *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"individualLeaderboard,omitempty"`
			PreventDonationsBeforeStart *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"preventDonationsBeforeStart,omitempty"`
			Registration *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"registration,omitempty"`
			StartsAt *struct {
				Visible *bool `json:"visible,omitempty"`
			} `json:"startsAt,omitempty"`
			TeamLeaderboard *struct {
				Type    *string `json:"type,omitempty"`
				Visible *bool   `json:"visible,omitempty"`
			} `json:"teamLeaderboard,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdVisibilityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdVisibilityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Avatar     *Image  `json:"avatar,omitempty"`
			Bio        *string `json:"bio,omitempty"`
			Disbanded  *bool   `json:"disbanded,omitempty"`
			Id         *int    `json:"id,omitempty"`
			InviteOnly *bool   `json:"inviteOnly,omitempty"`
			Name       *string `json:"name,omitempty"`
			Slug       *string `json:"slug,omitempty"`
			Social     *Social `json:"social,omitempty"`
			Url        *string `json:"url,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Avatar     *Image  `json:"avatar,omitempty"`
			Bio        *string `json:"bio,omitempty"`
			Disbanded  *bool   `json:"disbanded,omitempty"`
			Id         *int    `json:"id,omitempty"`
			InviteOnly *bool   `json:"inviteOnly,omitempty"`
			Name       *string `json:"name,omitempty"`
			Slug       *string `json:"slug,omitempty"`
			Social     *Social `json:"social,omitempty"`
			Url        *string `json:"url,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised       *int    `json:"amountRaised,omitempty"`
			CauseId            *int    `json:"causeId,omitempty"`
			Currency           *string `json:"currency,omitempty"`
			Description        *string `json:"description,omitempty"`
			EndsOn             *string `json:"endsOn,omitempty"`
			FundraisingEventId *int    `json:"fundraisingEventId,omitempty"`
			Goal               *int    `json:"goal,omitempty"`
			Name               *string `json:"name,omitempty"`
			OriginalGoal       *int    `json:"originalGoal,omitempty"`
			Slug               *string `json:"slug,omitempty"`
			StartsOn           *string `json:"startsOn,omitempty"`
			TeamId             *int    `json:"teamId,omitempty"`
			Thumbnail          *Image  `json:"thumbnail,omitempty"`
			TotalAmountRaised  *int    `json:"totalAmountRaised,omitempty"`
			Url                *string `json:"url,omitempty"`
			UserId             *int    `json:"userId,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdCampaignsCidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AmountRaised           *int        `json:"amountRaised,omitempty"`
			Avatar                 *Image      `json:"avatar,omitempty"`
			CauseId                *int        `json:"causeId,omitempty"`
			Description            *string     `json:"description,omitempty"`
			EndsAt                 *int        `json:"endsAt,omitempty"`
			FundraiserGoalAmount   *int        `json:"fundraiserGoalAmount,omitempty"`
			FundraisingEventId     *int        `json:"fundraisingEventId,omitempty"`
			Id                     *int        `json:"id,omitempty"`
			Livestream             *Livestream `json:"livestream,omitempty"`
			Name                   *string     `json:"name,omitempty"`
			OriginalGoalAmount     *int        `json:"originalGoalAmount,omitempty"`
			Slug                   *string     `json:"slug,omitempty"`
			StartsAt               *int        `json:"startsAt,omitempty"`
			Status                 *string     `json:"status,omitempty"`
			Supportable            *bool       `json:"supportable,omitempty"`
			SupportingAmountRaised *int        `json:"supportingAmountRaised,omitempty"`
			Team                   *struct {
				Avatar   *Image  `json:"avatar,omitempty"`
				Id       *int    `json:"id,omitempty"`
				Slug     *string `json:"slug,omitempty"`
				Url      *string `json:"url,omitempty"`
				Username *string `json:"username,omitempty"`
			} `json:"team,omitempty"`
			TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
			Url               *string `json:"url,omitempty"`
			User              *struct {
				Avatar   *Image  `json:"avatar,omitempty"`
				Id       *int    `json:"id,omitempty"`
				Slug     *string `json:"slug,omitempty"`
				Url      *string `json:"url,omitempty"`
				Username *string `json:"username,omitempty"`
			} `json:"user,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsIdCampaignsCidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdCampaignsCidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Id        *int    `json:"id,omitempty"`
			Slug      *string `json:"slug,omitempty"`
			Status    *string `json:"status,omitempty"`
			Thumbnail *Image  `json:"thumbnail,omitempty"`
			Username  *string `json:"username,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			About             *string  `json:"about,omitempty"`
			Avatar            *Image   `json:"avatar,omitempty"`
			Id                *int     `json:"id,omitempty"`
			Slug              *string  `json:"slug,omitempty"`
			Social            *Social  `json:"social,omitempty"`
			TotalAmountRaised *float32 `json:"totalAmountRaised,omitempty"`
			Url               *string  `json:"url,omitempty"`
			Username          *string  `json:"username,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			AmountRaised         *int                    `json:"amountRaised,omitempty"`
			CauseId              *int                    `json:"causeId,omitempty"`
			Currency             *string                 `json:"currency,omitempty"`
			Description          *string                 `json:"description,omitempty"`
			EndsOn               *string                 `json:"endsOn,omitempty"`
			FundraisingEventId   *int                    `json:"fundraisingEventId,omitempty"`
			Goal                 *int                    `json:"goal,omitempty"`
			Name                 *string                 `json:"name,omitempty"`
			OriginalGoal         *int                    `json:"originalGoal,omitempty"`
			Slug                 *string                 `json:"slug,omitempty"`
			StartsOn             *string                 `json:"startsOn,omitempty"`
			SupportingCampaignId *int                    `json:"supportingCampaignId,omitempty"`
			TeamId               *map[string]interface{} `json:"teamId,omitempty"`
			Thumbnail            *Image                  `json:"thumbnail,omitempty"`
			TotalAmountRaised    *int                    `json:"totalAmountRaised,omitempty"`
			Url                  *string                 `json:"url,omitempty"`
			UserId               *int                    `json:"userId,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdCampaignsCidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			AmountRaised           *int        `json:"amountRaised,omitempty"`
			Avatar                 *Image      `json:"avatar,omitempty"`
			CauseId                *int        `json:"causeId,omitempty"`
			Description            *string     `json:"description,omitempty"`
			EndsAt                 *int        `json:"endsAt,omitempty"`
			FundraiserGoalAmount   *int        `json:"fundraiserGoalAmount,omitempty"`
			FundraisingEventId     *int        `json:"fundraisingEventId,omitempty"`
			Id                     *int        `json:"id,omitempty"`
			Livestream             *Livestream `json:"livestream,omitempty"`
			Name                   *string     `json:"name,omitempty"`
			OriginalGoalAmount     *int        `json:"originalGoalAmount,omitempty"`
			Slug                   *string     `json:"slug,omitempty"`
			StartsAt               *int        `json:"startsAt,omitempty"`
			Status                 *string     `json:"status,omitempty"`
			Supportable            *bool       `json:"supportable,omitempty"`
			SupportingAmountRaised *int        `json:"supportingAmountRaised,omitempty"`
			Team                   *struct {
				Avatar   *Image  `json:"avatar,omitempty"`
				Id       *int    `json:"id,omitempty"`
				Slug     *string `json:"slug,omitempty"`
				Url      *string `json:"url,omitempty"`
				Username *string `json:"username,omitempty"`
			} `json:"team,omitempty"`
			TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
			Url               *string `json:"url,omitempty"`
			User              *struct {
				Avatar   *Image  `json:"avatar,omitempty"`
				Id       *int    `json:"id,omitempty"`
				Slug     *string `json:"slug,omitempty"`
				Url      *string `json:"url,omitempty"`
				Username *string `json:"username,omitempty"`
			} `json:"user,omitempty"`
		} `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdCampaignsCidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdCampaignsCidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdOwnedTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Avatar     *Image  `json:"avatar,omitempty"`
			Bio        *string `json:"bio,omitempty"`
			Disbanded  *bool   `json:"disbanded,omitempty"`
			Id         *int    `json:"id,omitempty"`
			InviteOnly *bool   `json:"inviteOnly,omitempty"`
			Name       *string `json:"name,omitempty"`
			Slug       *string `json:"slug,omitempty"`
			Social     *Social `json:"social,omitempty"`
			Url        *string `json:"url,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdOwnedTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdOwnedTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Avatar *Image  `json:"avatar,omitempty"`
			Id     *int    `json:"id,omitempty"`
			Name   *string `json:"name,omitempty"`
			Slug   *string `json:"slug,omitempty"`
			Url    *string `json:"url,omitempty"`
		} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCampaignsIdWithResponse request returning *GetCampaignsIdResponse
func (c *ClientWithResponses) GetCampaignsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCampaignsIdResponse, error) {
	rsp, err := c.GetCampaignsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdResponse(rsp)
}

// GetCampaignsIdChallengesWithResponse request returning *GetCampaignsIdChallengesResponse
func (c *ClientWithResponses) GetCampaignsIdChallengesWithResponse(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdChallengesResponse, error) {
	rsp, err := c.GetCampaignsIdChallenges(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdChallengesResponse(rsp)
}

// GetCampaignsIdDonationsWithResponse request returning *GetCampaignsIdDonationsResponse
func (c *ClientWithResponses) GetCampaignsIdDonationsWithResponse(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdDonationsResponse, error) {
	rsp, err := c.GetCampaignsIdDonations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdDonationsResponse(rsp)
}

// GetCampaignsIdPollsWithResponse request returning *GetCampaignsIdPollsResponse
func (c *ClientWithResponses) GetCampaignsIdPollsWithResponse(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdPollsResponse, error) {
	rsp, err := c.GetCampaignsIdPolls(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdPollsResponse(rsp)
}

// GetCampaignsIdRewardsWithResponse request returning *GetCampaignsIdRewardsResponse
func (c *ClientWithResponses) GetCampaignsIdRewardsWithResponse(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdRewardsResponse, error) {
	rsp, err := c.GetCampaignsIdRewards(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdRewardsResponse(rsp)
}

// GetCampaignsIdScheduleWithResponse request returning *GetCampaignsIdScheduleResponse
func (c *ClientWithResponses) GetCampaignsIdScheduleWithResponse(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdScheduleResponse, error) {
	rsp, err := c.GetCampaignsIdSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdScheduleResponse(rsp)
}

// GetCampaignsIdSupportingCampaignsWithResponse request returning *GetCampaignsIdSupportingCampaignsResponse
func (c *ClientWithResponses) GetCampaignsIdSupportingCampaignsWithResponse(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdSupportingCampaignsResponse, error) {
	rsp, err := c.GetCampaignsIdSupportingCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdSupportingCampaignsResponse(rsp)
}

// GetCausesIdWithResponse request returning *GetCausesIdResponse
func (c *ClientWithResponses) GetCausesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdResponse, error) {
	rsp, err := c.GetCausesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdResponse(rsp)
}

// GetCausesIdCampaignsWithResponse request returning *GetCausesIdCampaignsResponse
func (c *ClientWithResponses) GetCausesIdCampaignsWithResponse(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetCausesIdCampaignsResponse, error) {
	rsp, err := c.GetCausesIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdCampaignsResponse(rsp)
}

// GetCausesIdFundraisingEventsWithResponse request returning *GetCausesIdFundraisingEventsResponse
func (c *ClientWithResponses) GetCausesIdFundraisingEventsWithResponse(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetCausesIdFundraisingEventsResponse, error) {
	rsp, err := c.GetCausesIdFundraisingEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdFundraisingEventsResponse(rsp)
}

// GetCausesIdLeaderboardsWithResponse request returning *GetCausesIdLeaderboardsResponse
func (c *ClientWithResponses) GetCausesIdLeaderboardsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdLeaderboardsResponse, error) {
	rsp, err := c.GetCausesIdLeaderboards(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdLeaderboardsResponse(rsp)
}

// GetCausesIdPermissionsWithResponse request returning *GetCausesIdPermissionsResponse
func (c *ClientWithResponses) GetCausesIdPermissionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdPermissionsResponse, error) {
	rsp, err := c.GetCausesIdPermissions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdPermissionsResponse(rsp)
}

// GetCausesIdVisibilityOptionsWithResponse request returning *GetCausesIdVisibilityOptionsResponse
func (c *ClientWithResponses) GetCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetCausesIdVisibilityOptionsResponse, error) {
	rsp, err := c.GetCausesIdVisibilityOptions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdVisibilityOptionsResponse(rsp)
}

// PatchCausesIdVisibilityOptionsWithResponse request returning *PatchCausesIdVisibilityOptionsResponse
func (c *ClientWithResponses) PatchCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*PatchCausesIdVisibilityOptionsResponse, error) {
	rsp, err := c.PatchCausesIdVisibilityOptions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchCausesIdVisibilityOptionsResponse(rsp)
}

// GetFundraisingEventsWithResponse request returning *GetFundraisingEventsResponse
func (c *ClientWithResponses) GetFundraisingEventsWithResponse(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsResponse, error) {
	rsp, err := c.GetFundraisingEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsResponse(rsp)
}

// GetFundraisingEventsIdWithResponse request returning *GetFundraisingEventsIdResponse
func (c *ClientWithResponses) GetFundraisingEventsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdResponse, error) {
	rsp, err := c.GetFundraisingEventsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdResponse(rsp)
}

// GetFundraisingEventsIdCampaignsWithResponse request returning *GetFundraisingEventsIdCampaignsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdCampaignsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdCampaignsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdCampaignsResponse(rsp)
}

// GetFundraisingEventsIdIncentivesWithResponse request returning *GetFundraisingEventsIdIncentivesResponse
func (c *ClientWithResponses) GetFundraisingEventsIdIncentivesWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdIncentivesResponse, error) {
	rsp, err := c.GetFundraisingEventsIdIncentives(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdIncentivesResponse(rsp)
}

// GetFundraisingEventsIdLeaderboardsWithResponse request returning *GetFundraisingEventsIdLeaderboardsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdLeaderboardsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdLeaderboardsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdLeaderboards(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdLeaderboardsResponse(rsp)
}

// GetFundraisingEventsIdRegistrationFieldsWithResponse request returning *GetFundraisingEventsIdRegistrationFieldsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdRegistrationFieldsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationFieldsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdRegistrationFields(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdRegistrationFieldsResponse(rsp)
}

// GetFundraisingEventsIdRegistrationsWithResponse request returning *GetFundraisingEventsIdRegistrationsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdRegistrationsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdRegistrations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdRegistrationsResponse(rsp)
}

// GetFundraisingEventsIdScheduleWithResponse request returning *GetFundraisingEventsIdScheduleResponse
func (c *ClientWithResponses) GetFundraisingEventsIdScheduleWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdScheduleResponse, error) {
	rsp, err := c.GetFundraisingEventsIdSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdScheduleResponse(rsp)
}

// GetFundraisingEventsIdVisibilityOptionsWithResponse request returning *GetFundraisingEventsIdVisibilityOptionsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdVisibilityOptionsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdVisibilityOptions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdVisibilityOptionsResponse(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error) {
	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsResponse(rsp)
}

// GetTeamsIdWithResponse request returning *GetTeamsIdResponse
func (c *ClientWithResponses) GetTeamsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamsIdResponse, error) {
	rsp, err := c.GetTeamsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdResponse(rsp)
}

// GetTeamsIdCampaignsWithResponse request returning *GetTeamsIdCampaignsResponse
func (c *ClientWithResponses) GetTeamsIdCampaignsWithResponse(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsResponse, error) {
	rsp, err := c.GetTeamsIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdCampaignsResponse(rsp)
}

// GetTeamsIdCampaignsCidWithResponse request returning *GetTeamsIdCampaignsCidResponse
func (c *ClientWithResponses) GetTeamsIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsCidResponse, error) {
	rsp, err := c.GetTeamsIdCampaignsCid(ctx, id, cid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdCampaignsCidResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// GetUsersIdWithResponse request returning *GetUsersIdResponse
func (c *ClientWithResponses) GetUsersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error) {
	rsp, err := c.GetUsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdResponse(rsp)
}

// GetUsersIdCampaignsWithResponse request returning *GetUsersIdCampaignsResponse
func (c *ClientWithResponses) GetUsersIdCampaignsWithResponse(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsResponse, error) {
	rsp, err := c.GetUsersIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdCampaignsResponse(rsp)
}

// GetUsersIdCampaignsCidWithResponse request returning *GetUsersIdCampaignsCidResponse
func (c *ClientWithResponses) GetUsersIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsCidResponse, error) {
	rsp, err := c.GetUsersIdCampaignsCid(ctx, id, cid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdCampaignsCidResponse(rsp)
}

// GetUsersIdOwnedTeamsWithResponse request returning *GetUsersIdOwnedTeamsResponse
func (c *ClientWithResponses) GetUsersIdOwnedTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdOwnedTeamsResponse, error) {
	rsp, err := c.GetUsersIdOwnedTeams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdOwnedTeamsResponse(rsp)
}

// GetUsersIdTeamsWithResponse request returning *GetUsersIdTeamsResponse
func (c *ClientWithResponses) GetUsersIdTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdTeamsResponse, error) {
	rsp, err := c.GetUsersIdTeams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdTeamsResponse(rsp)
}

// ParseGetCampaignsIdResponse parses an HTTP response from a GetCampaignsIdWithResponse call
func ParseGetCampaignsIdResponse(rsp *http.Response) (*GetCampaignsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AmountRaised           *int        `json:"amountRaised,omitempty"`
				Avatar                 *Image      `json:"avatar,omitempty"`
				CauseId                *int        `json:"causeId,omitempty"`
				Description            *string     `json:"description,omitempty"`
				EndsAt                 *int        `json:"endsAt,omitempty"`
				FundraiserGoalAmount   *int        `json:"fundraiserGoalAmount,omitempty"`
				FundraisingEventId     *int        `json:"fundraisingEventId,omitempty"`
				Id                     *int        `json:"id,omitempty"`
				Livestream             *Livestream `json:"livestream,omitempty"`
				Name                   *string     `json:"name,omitempty"`
				OriginalGoalAmount     *int        `json:"originalGoalAmount,omitempty"`
				Slug                   *string     `json:"slug,omitempty"`
				StartsAt               *int        `json:"startsAt,omitempty"`
				Status                 *string     `json:"status,omitempty"`
				Supportable            *bool       `json:"supportable,omitempty"`
				SupportingAmountRaised *int        `json:"supportingAmountRaised,omitempty"`
				Team                   *struct {
					Avatar   *Image  `json:"avatar,omitempty"`
					Id       *int    `json:"id,omitempty"`
					Slug     *string `json:"slug,omitempty"`
					Url      *string `json:"url,omitempty"`
					Username *string `json:"username,omitempty"`
				} `json:"team,omitempty"`
				TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
				Url               *string `json:"url,omitempty"`
				User              *struct {
					Avatar   *Image  `json:"avatar,omitempty"`
					Id       *int    `json:"id,omitempty"`
					Slug     *string `json:"slug,omitempty"`
					Url      *string `json:"url,omitempty"`
					Username *string `json:"username,omitempty"`
				} `json:"user,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdChallengesResponse parses an HTTP response from a GetCampaignsIdChallengesWithResponse call
func ParseGetCampaignsIdChallengesResponse(rsp *http.Response) (*GetCampaignsIdChallengesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdChallengesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				ActivatesOn       *int    `json:"activatesOn,omitempty"`
				Active            *bool   `json:"active,omitempty"`
				Amount            *int    `json:"amount,omitempty"`
				CampaignId        *int    `json:"campaignId,omitempty"`
				CreatedAt         *int    `json:"createdAt,omitempty"`
				EndsAt            *int    `json:"endsAt,omitempty"`
				Id                *int    `json:"id,omitempty"`
				Name              *string `json:"name,omitempty"`
				TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
				UpdatedAt         *int    `json:"updatedAt,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdDonationsResponse parses an HTTP response from a GetCampaignsIdDonationsWithResponse call
func ParseGetCampaignsIdDonationsResponse(rsp *http.Response) (*GetCampaignsIdDonationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdDonationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Amount      *float32 `json:"amount,omitempty"`
				Comment     *string  `json:"comment,omitempty"`
				CompletedAt *int     `json:"completedAt,omitempty"`
				Id          *int     `json:"id,omitempty"`
				Name        *string  `json:"name,omitempty"`
				RewardId    *int     `json:"rewardId,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdPollsResponse parses an HTTP response from a GetCampaignsIdPollsWithResponse call
func ParseGetCampaignsIdPollsResponse(rsp *http.Response) (*GetCampaignsIdPollsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdPollsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Active     *bool   `json:"active,omitempty"`
				CampaignId *int    `json:"campaignId,omitempty"`
				CreatedAt  *int    `json:"createdAt,omitempty"`
				Id         *int    `json:"id,omitempty"`
				Name       *string `json:"name,omitempty"`
				Options    *[]struct {
					CreatedAt         *int    `json:"createdAt,omitempty"`
					Id                *int    `json:"id,omitempty"`
					Name              *string `json:"name,omitempty"`
					PollId            *int    `json:"pollId,omitempty"`
					TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
					UpdatedAt         *int    `json:"updatedAt,omitempty"`
				} `json:"options,omitempty"`
				UpdatedAt *int `json:"updatedAt,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdRewardsResponse parses an HTTP response from a GetCampaignsIdRewardsWithResponse call
func ParseGetCampaignsIdRewardsResponse(rsp *http.Response) (*GetCampaignsIdRewardsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdRewardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Active                  *bool                   `json:"active,omitempty"`
				Amount                  *int                    `json:"amount,omitempty"`
				CreatedAt               *int                    `json:"createdAt,omitempty"`
				Currency                *string                 `json:"currency,omitempty"`
				Description             *string                 `json:"description,omitempty"`
				FairMarketValue         *int                    `json:"fairMarketValue,omitempty"`
				Id                      *int                    `json:"id,omitempty"`
				Image                   *Image                  `json:"image,omitempty"`
				Kind                    *string                 `json:"kind,omitempty"`
				Name                    *string                 `json:"name,omitempty"`
				Quantity                *map[string]interface{} `json:"quantity,omitempty"`
				Remaining               *map[string]interface{} `json:"remaining,omitempty"`
				ShippingAddressRequired *bool                   `json:"shippingAddressRequired,omitempty"`
				ShippingNote            *map[string]interface{} `json:"shippingNote,omitempty"`
				StartsAt                *int                    `json:"startsAt,omitempty"`
				UpdatedAt               *int                    `json:"updatedAt,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdScheduleResponse parses an HTTP response from a GetCampaignsIdScheduleWithResponse call
func ParseGetCampaignsIdScheduleResponse(rsp *http.Response) (*GetCampaignsIdScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Description *string `json:"description,omitempty"`
				Id          *int    `json:"id,omitempty"`
				Name        *string `json:"name,omitempty"`
				StartsAt    *int    `json:"startsAt,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdSupportingCampaignsResponse parses an HTTP response from a GetCampaignsIdSupportingCampaignsWithResponse call
func ParseGetCampaignsIdSupportingCampaignsResponse(rsp *http.Response) (*GetCampaignsIdSupportingCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdSupportingCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised       *int                    `json:"amountRaised,omitempty"`
				CauseId            *int                    `json:"causeId,omitempty"`
				Description        *string                 `json:"description,omitempty"`
				EndsOn             *string                 `json:"endsOn,omitempty"`
				FundraisingEventId *int                    `json:"fundraisingEventId,omitempty"`
				Goal               *int                    `json:"goal,omitempty"`
				Id                 *int                    `json:"id,omitempty"`
				Name               *string                 `json:"name,omitempty"`
				OriginalGoal       *int                    `json:"originalGoal,omitempty"`
				Slug               *string                 `json:"slug,omitempty"`
				StartsOn           *string                 `json:"startsOn,omitempty"`
				TeamId             *map[string]interface{} `json:"teamId,omitempty"`
				Thumbnail          *Image                  `json:"thumbnail,omitempty"`
				TotalAmountRaised  *int                    `json:"totalAmountRaised,omitempty"`
				Url                *string                 `json:"url,omitempty"`
				UserId             *int                    `json:"userId,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdResponse parses an HTTP response from a GetCausesIdWithResponse call
func ParseGetCausesIdResponse(rsp *http.Response) (*GetCausesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				About   *string `json:"about,omitempty"`
				Address *struct {
					AddressLine1 *string `json:"addressLine1,omitempty"`
					AddressLine2 *string `json:"addressLine2,omitempty"`
					City         *string `json:"city,omitempty"`
					Country      *string `json:"country,omitempty"`
					PostalCode   *string `json:"postalCode,omitempty"`
					Region       *string `json:"region,omitempty"`
				} `json:"address,omitempty"`
				Avatar             *Image  `json:"avatar,omitempty"`
				Banner             *Image  `json:"banner,omitempty"`
				ContactEmail       *string `json:"contactEmail,omitempty"`
				Currency           *string `json:"currency,omitempty"`
				Id                 *int    `json:"id,omitempty"`
				Image              *Image  `json:"image,omitempty"`
				LegalName          *string `json:"legalName,omitempty"`
				Logo               *Image  `json:"logo,omitempty"`
				MailchimpConnected *bool   `json:"mailchimpConnected,omitempty"`
				Name               *string `json:"name,omitempty"`
				PaypalCurrencyCode *string `json:"paypalCurrencyCode,omitempty"`
				PaypalEmail        *string `json:"paypalEmail,omitempty"`
				Settings           *struct {
					Colors *struct {
						Background *string `json:"background,omitempty"`
						Highlight  *string `json:"highlight,omitempty"`
					} `json:"colors,omitempty"`
					FindOutMoreLink *string `json:"findOutMoreLink,omitempty"`
					FooterCopyright *string `json:"footerCopyright,omitempty"`
					HeaderIntro     *string `json:"headerIntro,omitempty"`
					HeaderTitle     *string `json:"headerTitle,omitempty"`
				} `json:"settings,omitempty"`
				Slug            *string `json:"slug,omitempty"`
				Social          *Social `json:"social,omitempty"`
				Status          *string `json:"status,omitempty"`
				StripeConnected *bool   `json:"stripeConnected,omitempty"`
				Video           *string `json:"video,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdCampaignsResponse parses an HTTP response from a GetCausesIdCampaignsWithResponse call
func ParseGetCausesIdCampaignsResponse(rsp *http.Response) (*GetCausesIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised       *int                    `json:"amountRaised,omitempty"`
				CauseId            *int                    `json:"causeId,omitempty"`
				Currency           *string                 `json:"currency,omitempty"`
				Description        *string                 `json:"description,omitempty"`
				EndsOn             *string                 `json:"endsOn,omitempty"`
				FundraisingEventId *int                    `json:"fundraisingEventId,omitempty"`
				Goal               *int                    `json:"goal,omitempty"`
				Name               *string                 `json:"name,omitempty"`
				OriginalGoal       *int                    `json:"originalGoal,omitempty"`
				Slug               *string                 `json:"slug,omitempty"`
				StartsOn           *string                 `json:"startsOn,omitempty"`
				TeamId             *map[string]interface{} `json:"teamId,omitempty"`
				Thumbnail          *Image                  `json:"thumbnail,omitempty"`
				TotalAmountRaised  *int                    `json:"totalAmountRaised,omitempty"`
				Url                *string                 `json:"url,omitempty"`
				UserId             *int                    `json:"userId,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdFundraisingEventsResponse parses an HTTP response from a GetCausesIdFundraisingEventsWithResponse call
func ParseGetCausesIdFundraisingEventsResponse(rsp *http.Response) (*GetCausesIdFundraisingEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdFundraisingEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised *int    `json:"amountRaised,omitempty"`
				Avatar       *Image  `json:"avatar,omitempty"`
				Banner       *Image  `json:"banner,omitempty"`
				BannerIntro  *string `json:"bannerIntro,omitempty"`
				BannerTitle  *string `json:"bannerTitle,omitempty"`
				CauseId      *int    `json:"causeId,omitempty"`
				Currency     *string `json:"currency,omitempty"`
				Description  *string `json:"description,omitempty"`
				EndsOn       *string `json:"endsOn,omitempty"`
				Goal         *int    `json:"goal,omitempty"`
				Id           *int    `json:"id,omitempty"`
				Image        *Image  `json:"image,omitempty"`
				Logo         *Image  `json:"logo,omitempty"`
				Name         *string `json:"name,omitempty"`
				Slug         *string `json:"slug,omitempty"`
				StartsOn     *string `json:"startsOn,omitempty"`
				Url          *string `json:"url,omitempty"`
				Video        *Image  `json:"video,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdLeaderboardsResponse parses an HTTP response from a GetCausesIdLeaderboardsWithResponse call
func ParseGetCausesIdLeaderboardsResponse(rsp *http.Response) (*GetCausesIdLeaderboardsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdLeaderboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised *int    `json:"amountRaised,omitempty"`
				Avatar       *Image  `json:"avatar,omitempty"`
				Banner       *Image  `json:"banner,omitempty"`
				BannerIntro  *string `json:"bannerIntro,omitempty"`
				BannerTitle  *string `json:"bannerTitle,omitempty"`
				CauseId      *int    `json:"causeId,omitempty"`
				Currency     *string `json:"currency,omitempty"`
				Description  *string `json:"description,omitempty"`
				EndsOn       *string `json:"endsOn,omitempty"`
				Goal         *int    `json:"goal,omitempty"`
				Id           *int    `json:"id,omitempty"`
				Image        *Image  `json:"image,omitempty"`
				Logo         *Image  `json:"logo,omitempty"`
				Name         *string `json:"name,omitempty"`
				Slug         *string `json:"slug,omitempty"`
				StartsOn     *string `json:"startsOn,omitempty"`
				Url          *string `json:"url,omitempty"`
				Video        *Image  `json:"video,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdPermissionsResponse parses an HTTP response from a GetCausesIdPermissionsWithResponse call
func ParseGetCausesIdPermissionsResponse(rsp *http.Response) (*GetCausesIdPermissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Activated                               *bool `json:"activated,omitempty"`
				AdminApiEnabled                         *bool `json:"adminApiEnabled,omitempty"`
				AdminBrandingColors                     *bool `json:"adminBrandingColors,omitempty"`
				AdminBrandingDetails                    *bool `json:"adminBrandingDetails,omitempty"`
				AdminBrandingEnabled                    *bool `json:"adminBrandingEnabled,omitempty"`
				AdminBrandingImages                     *bool `json:"adminBrandingImages,omitempty"`
				AdminEnabled                            *bool `json:"adminEnabled,omitempty"`
				AdminFinanceEnabled                     *bool `json:"adminFinanceEnabled,omitempty"`
				AdminGeneralEnabled                     *bool `json:"adminGeneralEnabled,omitempty"`
				AdminIntegrationsEnabled                *bool `json:"adminIntegrationsEnabled,omitempty"`
				AdminVisibilityEnabled                  *bool `json:"adminVisibilityEnabled,omitempty"`
				CauseLeaderboard                        *bool `json:"causeLeaderboard,omitempty"`
				DashboardChart                          *bool `json:"dashboardChart,omitempty"`
				DashboardEnabled                        *bool `json:"dashboardEnabled,omitempty"`
				FundraisingEventsEnabled                *bool `json:"fundraisingEventsEnabled,omitempty"`
				FundraisingEventsGeneralColors          *bool `json:"fundraisingEventsGeneralColors,omitempty"`
				FundraisingEventsGeneralDetails         *bool `json:"fundraisingEventsGeneralDetails,omitempty"`
				FundraisingEventsGeneralEnabled         *bool `json:"fundraisingEventsGeneralEnabled,omitempty"`
				FundraisingEventsGeneralImages          *bool `json:"fundraisingEventsGeneralImages,omitempty"`
				FundraisingEventsIncentives             *bool `json:"fundraisingEventsIncentives,omitempty"`
				FundraisingEventsLeaderboard            *bool `json:"fundraisingEventsLeaderboard,omitempty"`
				FundraisingEventsRegistrationEnabled    *bool `json:"fundraisingEventsRegistrationEnabled,omitempty"`
				FundraisingEventsReporting              *bool `json:"fundraisingEventsReporting,omitempty"`
				FundraisingEventsReportingCampaigns     *bool `json:"fundraisingEventsReportingCampaigns,omitempty"`
				FundraisingEventsReportingDonations     *bool `json:"fundraisingEventsReportingDonations,omitempty"`
				FundraisingEventsReportingFundraisers   *bool `json:"fundraisingEventsReportingFundraisers,omitempty"`
				FundraisingEventsSchedule               *bool `json:"fundraisingEventsSchedule,omitempty"`
				FundraisingEventsVisibilityDetails      *bool `json:"fundraisingEventsVisibilityDetails,omitempty"`
				FundraisingEventsVisibilityEnabled      *bool `json:"fundraisingEventsVisibilityEnabled,omitempty"`
				FundraisingEventsVisibilityLeaderboards *bool `json:"fundraisingEventsVisibilityLeaderboards,omitempty"`
				ReportingCampaigns                      *bool `json:"reportingCampaigns,omitempty"`
				ReportingChart                          *bool `json:"reportingChart,omitempty"`
				ReportingDonations                      *bool `json:"reportingDonations,omitempty"`
				ReportingEnabled                        *bool `json:"reportingEnabled,omitempty"`
				ReportingFundraisers                    *bool `json:"reportingFundraisers,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdVisibilityOptionsResponse parses an HTTP response from a GetCausesIdVisibilityOptionsWithResponse call
func ParseGetCausesIdVisibilityOptionsResponse(rsp *http.Response) (*GetCausesIdVisibilityOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdVisibilityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Donate *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"donate,omitempty"`
				DonorLeaderboard *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"donorLeaderboard,omitempty"`
				EndsAt *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"endsAt,omitempty"`
				FundraiserGoalAmount *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"fundraiserGoalAmount,omitempty"`
				IndividualLeaderboard *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"individualLeaderboard,omitempty"`
				PreventDonationsBeforeStart *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"preventDonationsBeforeStart,omitempty"`
				Registration *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"registration,omitempty"`
				StartsAt *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"startsAt,omitempty"`
				TeamLeaderboard *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"teamLeaderboard,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePatchCausesIdVisibilityOptionsResponse parses an HTTP response from a PatchCausesIdVisibilityOptionsWithResponse call
func ParsePatchCausesIdVisibilityOptionsResponse(rsp *http.Response) (*PatchCausesIdVisibilityOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchCausesIdVisibilityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Donate *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"donate,omitempty"`
				DonorLeaderboard *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"donorLeaderboard,omitempty"`
				EndsAt *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"endsAt,omitempty"`
				FundraiserGoalAmount *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"fundraiserGoalAmount,omitempty"`
				IndividualLeaderboard *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"individualLeaderboard,omitempty"`
				PreventDonationsBeforeStart *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"preventDonationsBeforeStart,omitempty"`
				Registration *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"registration,omitempty"`
				StartsAt *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"startsAt,omitempty"`
				TeamLeaderboard *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"teamLeaderboard,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsResponse parses an HTTP response from a GetFundraisingEventsWithResponse call
func ParseGetFundraisingEventsResponse(rsp *http.Response) (*GetFundraisingEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised *int    `json:"amountRaised,omitempty"`
				Avatar       *Image  `json:"avatar,omitempty"`
				Banner       *Image  `json:"banner,omitempty"`
				BannerIntro  *string `json:"bannerIntro,omitempty"`
				BannerTitle  *string `json:"bannerTitle,omitempty"`
				CauseId      *int    `json:"causeId,omitempty"`
				Currency     *string `json:"currency,omitempty"`
				Description  *string `json:"description,omitempty"`
				EndsOn       *string `json:"endsOn,omitempty"`
				Goal         *int    `json:"goal,omitempty"`
				Id           *int    `json:"id,omitempty"`
				Image        *Image  `json:"image,omitempty"`
				Logo         *Image  `json:"logo,omitempty"`
				Name         *string `json:"name,omitempty"`
				Slug         *string `json:"slug,omitempty"`
				StartsOn     *string `json:"startsOn,omitempty"`
				Url          *string `json:"url,omitempty"`
				Video        *Image  `json:"video,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdResponse parses an HTTP response from a GetFundraisingEventsIdWithResponse call
func ParseGetFundraisingEventsIdResponse(rsp *http.Response) (*GetFundraisingEventsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AmountRaised *int    `json:"amountRaised,omitempty"`
				Avatar       *Image  `json:"avatar,omitempty"`
				Banner       *Image  `json:"banner,omitempty"`
				BannerIntro  *string `json:"bannerIntro,omitempty"`
				BannerTitle  *string `json:"bannerTitle,omitempty"`
				CauseId      *int    `json:"causeId,omitempty"`
				Currency     *string `json:"currency,omitempty"`
				Description  *string `json:"description,omitempty"`
				EndsOn       *string `json:"endsOn,omitempty"`
				Goal         *int    `json:"goal,omitempty"`
				Id           *int    `json:"id,omitempty"`
				Image        *Image  `json:"image,omitempty"`
				Logo         *Image  `json:"logo,omitempty"`
				Name         *string `json:"name,omitempty"`
				Slug         *string `json:"slug,omitempty"`
				StartsOn     *string `json:"startsOn,omitempty"`
				Url          *string `json:"url,omitempty"`
				Video        *Image  `json:"video,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdCampaignsResponse parses an HTTP response from a GetFundraisingEventsIdCampaignsWithResponse call
func ParseGetFundraisingEventsIdCampaignsResponse(rsp *http.Response) (*GetFundraisingEventsIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised       *int                    `json:"amountRaised,omitempty"`
				CauseId            *int                    `json:"causeId,omitempty"`
				Currency           *string                 `json:"currency,omitempty"`
				Description        *string                 `json:"description,omitempty"`
				EndsOn             *string                 `json:"endsOn,omitempty"`
				FundraisingEventId *int                    `json:"fundraisingEventId,omitempty"`
				Goal               *int                    `json:"goal,omitempty"`
				Name               *string                 `json:"name,omitempty"`
				OriginalGoal       *int                    `json:"originalGoal,omitempty"`
				Slug               *string                 `json:"slug,omitempty"`
				StartsOn           *string                 `json:"startsOn,omitempty"`
				TeamId             *map[string]interface{} `json:"teamId,omitempty"`
				Thumbnail          *Image                  `json:"thumbnail,omitempty"`
				TotalAmountRaised  *int                    `json:"totalAmountRaised,omitempty"`
				Url                *string                 `json:"url,omitempty"`
				UserId             *int                    `json:"userId,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdIncentivesResponse parses an HTTP response from a GetFundraisingEventsIdIncentivesWithResponse call
func ParseGetFundraisingEventsIdIncentivesResponse(rsp *http.Response) (*GetFundraisingEventsIdIncentivesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdIncentivesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				CreatedAt   *int    `json:"createdAt,omitempty"`
				Description *string `json:"description,omitempty"`
				Id          *int    `json:"id,omitempty"`
				Image       *Image  `json:"image,omitempty"`
				Title       *string `json:"title,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdLeaderboardsResponse parses an HTTP response from a GetFundraisingEventsIdLeaderboardsWithResponse call
func ParseGetFundraisingEventsIdLeaderboardsResponse(rsp *http.Response) (*GetFundraisingEventsIdLeaderboardsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdLeaderboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Individual *[]struct {
					AmountRaised *int    `json:"amount_raised,omitempty"`
					Name         *string `json:"name,omitempty"`
					Url          *string `json:"url,omitempty"`
					UserId       *int    `json:"userId,omitempty"`
				} `json:"individual,omitempty"`
				Team *[]struct {
					AmountRaised *int    `json:"amount_raised,omitempty"`
					Name         *string `json:"name,omitempty"`
					TeamId       *int    `json:"teamId,omitempty"`
					Url          *string `json:"url,omitempty"`
				} `json:"team,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdRegistrationFieldsResponse parses an HTTP response from a GetFundraisingEventsIdRegistrationFieldsWithResponse call
func ParseGetFundraisingEventsIdRegistrationFieldsResponse(rsp *http.Response) (*GetFundraisingEventsIdRegistrationFieldsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdRegistrationFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Address *struct {
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"address,omitempty"`
				ServiceHours *struct {
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"service_hours,omitempty"`
				ShirtSize *struct {
					Enabled *bool `json:"enabled,omitempty"`
				} `json:"shirt_size,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdRegistrationsResponse parses an HTTP response from a GetFundraisingEventsIdRegistrationsWithResponse call
func ParseGetFundraisingEventsIdRegistrationsResponse(rsp *http.Response) (*GetFundraisingEventsIdRegistrationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdRegistrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Address *struct {
					AddressLine1 *string `json:"addressLine1,omitempty"`
					AddressLine2 *string `json:"addressLine2,omitempty"`
					City         *string `json:"city,omitempty"`
					PostalCode   *string `json:"postalCode,omitempty"`
					State        *string `json:"state,omitempty"`
				} `json:"address,omitempty"`
				Email        *string `json:"email,omitempty"`
				Id           *int    `json:"id,omitempty"`
				RegisteredAt *string `json:"registeredAt,omitempty"`
				ServiceHours *bool   `json:"serviceHours,omitempty"`
				ShirtSize    *string `json:"shirtSize,omitempty"`
				Subscribed   *bool   `json:"subscribed,omitempty"`
				UserId       *int    `json:"userId,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdScheduleResponse parses an HTTP response from a GetFundraisingEventsIdScheduleWithResponse call
func ParseGetFundraisingEventsIdScheduleResponse(rsp *http.Response) (*GetFundraisingEventsIdScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Description *string `json:"description,omitempty"`
				Id          *int    `json:"id,omitempty"`
				Name        *string `json:"name,omitempty"`
				StartsAt    *int    `json:"startsAt,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdVisibilityOptionsResponse parses an HTTP response from a GetFundraisingEventsIdVisibilityOptionsWithResponse call
func ParseGetFundraisingEventsIdVisibilityOptionsResponse(rsp *http.Response) (*GetFundraisingEventsIdVisibilityOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdVisibilityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Donate *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"donate,omitempty"`
				DonorLeaderboard *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"donorLeaderboard,omitempty"`
				EndsAt *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"endsAt,omitempty"`
				FundraiserGoalAmount *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"fundraiserGoalAmount,omitempty"`
				IndividualLeaderboard *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"individualLeaderboard,omitempty"`
				PreventDonationsBeforeStart *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"preventDonationsBeforeStart,omitempty"`
				Registration *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"registration,omitempty"`
				StartsAt *struct {
					Visible *bool `json:"visible,omitempty"`
				} `json:"startsAt,omitempty"`
				TeamLeaderboard *struct {
					Type    *string `json:"type,omitempty"`
					Visible *bool   `json:"visible,omitempty"`
				} `json:"teamLeaderboard,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Avatar     *Image  `json:"avatar,omitempty"`
				Bio        *string `json:"bio,omitempty"`
				Disbanded  *bool   `json:"disbanded,omitempty"`
				Id         *int    `json:"id,omitempty"`
				InviteOnly *bool   `json:"inviteOnly,omitempty"`
				Name       *string `json:"name,omitempty"`
				Slug       *string `json:"slug,omitempty"`
				Social     *Social `json:"social,omitempty"`
				Url        *string `json:"url,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsIdResponse parses an HTTP response from a GetTeamsIdWithResponse call
func ParseGetTeamsIdResponse(rsp *http.Response) (*GetTeamsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Avatar     *Image  `json:"avatar,omitempty"`
				Bio        *string `json:"bio,omitempty"`
				Disbanded  *bool   `json:"disbanded,omitempty"`
				Id         *int    `json:"id,omitempty"`
				InviteOnly *bool   `json:"inviteOnly,omitempty"`
				Name       *string `json:"name,omitempty"`
				Slug       *string `json:"slug,omitempty"`
				Social     *Social `json:"social,omitempty"`
				Url        *string `json:"url,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsIdCampaignsResponse parses an HTTP response from a GetTeamsIdCampaignsWithResponse call
func ParseGetTeamsIdCampaignsResponse(rsp *http.Response) (*GetTeamsIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised       *int    `json:"amountRaised,omitempty"`
				CauseId            *int    `json:"causeId,omitempty"`
				Currency           *string `json:"currency,omitempty"`
				Description        *string `json:"description,omitempty"`
				EndsOn             *string `json:"endsOn,omitempty"`
				FundraisingEventId *int    `json:"fundraisingEventId,omitempty"`
				Goal               *int    `json:"goal,omitempty"`
				Name               *string `json:"name,omitempty"`
				OriginalGoal       *int    `json:"originalGoal,omitempty"`
				Slug               *string `json:"slug,omitempty"`
				StartsOn           *string `json:"startsOn,omitempty"`
				TeamId             *int    `json:"teamId,omitempty"`
				Thumbnail          *Image  `json:"thumbnail,omitempty"`
				TotalAmountRaised  *int    `json:"totalAmountRaised,omitempty"`
				Url                *string `json:"url,omitempty"`
				UserId             *int    `json:"userId,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsIdCampaignsCidResponse parses an HTTP response from a GetTeamsIdCampaignsCidWithResponse call
func ParseGetTeamsIdCampaignsCidResponse(rsp *http.Response) (*GetTeamsIdCampaignsCidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdCampaignsCidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AmountRaised           *int        `json:"amountRaised,omitempty"`
				Avatar                 *Image      `json:"avatar,omitempty"`
				CauseId                *int        `json:"causeId,omitempty"`
				Description            *string     `json:"description,omitempty"`
				EndsAt                 *int        `json:"endsAt,omitempty"`
				FundraiserGoalAmount   *int        `json:"fundraiserGoalAmount,omitempty"`
				FundraisingEventId     *int        `json:"fundraisingEventId,omitempty"`
				Id                     *int        `json:"id,omitempty"`
				Livestream             *Livestream `json:"livestream,omitempty"`
				Name                   *string     `json:"name,omitempty"`
				OriginalGoalAmount     *int        `json:"originalGoalAmount,omitempty"`
				Slug                   *string     `json:"slug,omitempty"`
				StartsAt               *int        `json:"startsAt,omitempty"`
				Status                 *string     `json:"status,omitempty"`
				Supportable            *bool       `json:"supportable,omitempty"`
				SupportingAmountRaised *int        `json:"supportingAmountRaised,omitempty"`
				Team                   *struct {
					Avatar   *Image  `json:"avatar,omitempty"`
					Id       *int    `json:"id,omitempty"`
					Slug     *string `json:"slug,omitempty"`
					Url      *string `json:"url,omitempty"`
					Username *string `json:"username,omitempty"`
				} `json:"team,omitempty"`
				TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
				Url               *string `json:"url,omitempty"`
				User              *struct {
					Avatar   *Image  `json:"avatar,omitempty"`
					Id       *int    `json:"id,omitempty"`
					Slug     *string `json:"slug,omitempty"`
					Url      *string `json:"url,omitempty"`
					Username *string `json:"username,omitempty"`
				} `json:"user,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Id        *int    `json:"id,omitempty"`
				Slug      *string `json:"slug,omitempty"`
				Status    *string `json:"status,omitempty"`
				Thumbnail *Image  `json:"thumbnail,omitempty"`
				Username  *string `json:"username,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdResponse parses an HTTP response from a GetUsersIdWithResponse call
func ParseGetUsersIdResponse(rsp *http.Response) (*GetUsersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				About             *string  `json:"about,omitempty"`
				Avatar            *Image   `json:"avatar,omitempty"`
				Id                *int     `json:"id,omitempty"`
				Slug              *string  `json:"slug,omitempty"`
				Social            *Social  `json:"social,omitempty"`
				TotalAmountRaised *float32 `json:"totalAmountRaised,omitempty"`
				Url               *string  `json:"url,omitempty"`
				Username          *string  `json:"username,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdCampaignsResponse parses an HTTP response from a GetUsersIdCampaignsWithResponse call
func ParseGetUsersIdCampaignsResponse(rsp *http.Response) (*GetUsersIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				AmountRaised         *int                    `json:"amountRaised,omitempty"`
				CauseId              *int                    `json:"causeId,omitempty"`
				Currency             *string                 `json:"currency,omitempty"`
				Description          *string                 `json:"description,omitempty"`
				EndsOn               *string                 `json:"endsOn,omitempty"`
				FundraisingEventId   *int                    `json:"fundraisingEventId,omitempty"`
				Goal                 *int                    `json:"goal,omitempty"`
				Name                 *string                 `json:"name,omitempty"`
				OriginalGoal         *int                    `json:"originalGoal,omitempty"`
				Slug                 *string                 `json:"slug,omitempty"`
				StartsOn             *string                 `json:"startsOn,omitempty"`
				SupportingCampaignId *int                    `json:"supportingCampaignId,omitempty"`
				TeamId               *map[string]interface{} `json:"teamId,omitempty"`
				Thumbnail            *Image                  `json:"thumbnail,omitempty"`
				TotalAmountRaised    *int                    `json:"totalAmountRaised,omitempty"`
				Url                  *string                 `json:"url,omitempty"`
				UserId               *int                    `json:"userId,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdCampaignsCidResponse parses an HTTP response from a GetUsersIdCampaignsCidWithResponse call
func ParseGetUsersIdCampaignsCidResponse(rsp *http.Response) (*GetUsersIdCampaignsCidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdCampaignsCidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				AmountRaised           *int        `json:"amountRaised,omitempty"`
				Avatar                 *Image      `json:"avatar,omitempty"`
				CauseId                *int        `json:"causeId,omitempty"`
				Description            *string     `json:"description,omitempty"`
				EndsAt                 *int        `json:"endsAt,omitempty"`
				FundraiserGoalAmount   *int        `json:"fundraiserGoalAmount,omitempty"`
				FundraisingEventId     *int        `json:"fundraisingEventId,omitempty"`
				Id                     *int        `json:"id,omitempty"`
				Livestream             *Livestream `json:"livestream,omitempty"`
				Name                   *string     `json:"name,omitempty"`
				OriginalGoalAmount     *int        `json:"originalGoalAmount,omitempty"`
				Slug                   *string     `json:"slug,omitempty"`
				StartsAt               *int        `json:"startsAt,omitempty"`
				Status                 *string     `json:"status,omitempty"`
				Supportable            *bool       `json:"supportable,omitempty"`
				SupportingAmountRaised *int        `json:"supportingAmountRaised,omitempty"`
				Team                   *struct {
					Avatar   *Image  `json:"avatar,omitempty"`
					Id       *int    `json:"id,omitempty"`
					Slug     *string `json:"slug,omitempty"`
					Url      *string `json:"url,omitempty"`
					Username *string `json:"username,omitempty"`
				} `json:"team,omitempty"`
				TotalAmountRaised *int    `json:"totalAmountRaised,omitempty"`
				Url               *string `json:"url,omitempty"`
				User              *struct {
					Avatar   *Image  `json:"avatar,omitempty"`
					Id       *int    `json:"id,omitempty"`
					Slug     *string `json:"slug,omitempty"`
					Url      *string `json:"url,omitempty"`
					Username *string `json:"username,omitempty"`
				} `json:"user,omitempty"`
			} `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdOwnedTeamsResponse parses an HTTP response from a GetUsersIdOwnedTeamsWithResponse call
func ParseGetUsersIdOwnedTeamsResponse(rsp *http.Response) (*GetUsersIdOwnedTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdOwnedTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Avatar     *Image  `json:"avatar,omitempty"`
				Bio        *string `json:"bio,omitempty"`
				Disbanded  *bool   `json:"disbanded,omitempty"`
				Id         *int    `json:"id,omitempty"`
				InviteOnly *bool   `json:"inviteOnly,omitempty"`
				Name       *string `json:"name,omitempty"`
				Slug       *string `json:"slug,omitempty"`
				Social     *Social `json:"social,omitempty"`
				Url        *string `json:"url,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdTeamsResponse parses an HTTP response from a GetUsersIdTeamsWithResponse call
func ParseGetUsersIdTeamsResponse(rsp *http.Response) (*GetUsersIdTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Avatar *Image  `json:"avatar,omitempty"`
				Id     *int    `json:"id,omitempty"`
				Name   *string `json:"name,omitempty"`
				Slug   *string `json:"slug,omitempty"`
				Url    *string `json:"url,omitempty"`
			} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /campaigns/{id})
	GetCampaignsId(ctx echo.Context, id int) error

	// (GET /campaigns/{id}/challenges)
	GetCampaignsIdChallenges(ctx echo.Context, id int, params GetCampaignsIdChallengesParams) error

	// (GET /campaigns/{id}/donations)
	GetCampaignsIdDonations(ctx echo.Context, id int, params GetCampaignsIdDonationsParams) error

	// (GET /campaigns/{id}/polls)
	GetCampaignsIdPolls(ctx echo.Context, id int, params GetCampaignsIdPollsParams) error

	// (GET /campaigns/{id}/rewards)
	GetCampaignsIdRewards(ctx echo.Context, id int, params GetCampaignsIdRewardsParams) error

	// (GET /campaigns/{id}/schedule)
	GetCampaignsIdSchedule(ctx echo.Context, id int, params GetCampaignsIdScheduleParams) error

	// (GET /campaigns/{id}/supporting-campaigns)
	GetCampaignsIdSupportingCampaigns(ctx echo.Context, id int, params GetCampaignsIdSupportingCampaignsParams) error

	// (GET /causes/{id})
	GetCausesId(ctx echo.Context, id int) error

	// (GET /causes/{id}/campaigns)
	GetCausesIdCampaigns(ctx echo.Context, id int, params GetCausesIdCampaignsParams) error

	// (GET /causes/{id}/fundraising-events)
	GetCausesIdFundraisingEvents(ctx echo.Context, id int, params GetCausesIdFundraisingEventsParams) error

	// (GET /causes/{id}/leaderboards)
	GetCausesIdLeaderboards(ctx echo.Context, id int) error

	// (GET /causes/{id}/permissions)
	GetCausesIdPermissions(ctx echo.Context, id int) error

	// (GET /causes/{id}/visibility-options)
	GetCausesIdVisibilityOptions(ctx echo.Context, id int, params GetCausesIdVisibilityOptionsParams) error

	// (PATCH /causes/{id}/visibility-options)
	PatchCausesIdVisibilityOptions(ctx echo.Context, id int) error

	// (GET /fundraising-events)
	GetFundraisingEvents(ctx echo.Context, params GetFundraisingEventsParams) error

	// (GET /fundraising-events/{id})
	GetFundraisingEventsId(ctx echo.Context, id int) error

	// (GET /fundraising-events/{id}/campaigns)
	GetFundraisingEventsIdCampaigns(ctx echo.Context, id int, params GetFundraisingEventsIdCampaignsParams) error

	// (GET /fundraising-events/{id}/incentives)
	GetFundraisingEventsIdIncentives(ctx echo.Context, id int, params GetFundraisingEventsIdIncentivesParams) error

	// (GET /fundraising-events/{id}/leaderboards)
	GetFundraisingEventsIdLeaderboards(ctx echo.Context, id int, params GetFundraisingEventsIdLeaderboardsParams) error

	// (GET /fundraising-events/{id}/registration-fields)
	GetFundraisingEventsIdRegistrationFields(ctx echo.Context, id int, params GetFundraisingEventsIdRegistrationFieldsParams) error

	// (GET /fundraising-events/{id}/registrations)
	GetFundraisingEventsIdRegistrations(ctx echo.Context, id int, params GetFundraisingEventsIdRegistrationsParams) error

	// (GET /fundraising-events/{id}/schedule)
	GetFundraisingEventsIdSchedule(ctx echo.Context, id int, params GetFundraisingEventsIdScheduleParams) error

	// (GET /fundraising-events/{id}/visibility-options)
	GetFundraisingEventsIdVisibilityOptions(ctx echo.Context, id int, params GetFundraisingEventsIdVisibilityOptionsParams) error

	// (GET /teams)
	GetTeams(ctx echo.Context, params GetTeamsParams) error

	// (GET /teams/{id})
	GetTeamsId(ctx echo.Context, id int) error

	// (GET /teams/{id}/campaigns)
	GetTeamsIdCampaigns(ctx echo.Context, id int, params GetTeamsIdCampaignsParams) error

	// (GET /teams/{id}/campaigns/{cid})
	GetTeamsIdCampaignsCid(ctx echo.Context, id int, cid int) error

	// (GET /user)
	GetUser(ctx echo.Context) error

	// (GET /users/{id})
	GetUsersId(ctx echo.Context, id int) error

	// (GET /users/{id}/campaigns)
	GetUsersIdCampaigns(ctx echo.Context, id int, params GetUsersIdCampaignsParams) error

	// (GET /users/{id}/campaigns/{cid})
	GetUsersIdCampaignsCid(ctx echo.Context, id int, cid int) error

	// (GET /users/{id}/owned-teams)
	GetUsersIdOwnedTeams(ctx echo.Context, id int, params GetUsersIdOwnedTeamsParams) error

	// (GET /users/{id}/teams)
	GetUsersIdTeams(ctx echo.Context, id int, params GetUsersIdTeamsParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetCampaignsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampaignsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCampaignsId(ctx, id)
	return err
}

// GetCampaignsIdChallenges converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampaignsIdChallenges(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCampaignsIdChallengesParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCampaignsIdChallenges(ctx, id, params)
	return err
}

// GetCampaignsIdDonations converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampaignsIdDonations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCampaignsIdDonationsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCampaignsIdDonations(ctx, id, params)
	return err
}

// GetCampaignsIdPolls converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampaignsIdPolls(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCampaignsIdPollsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCampaignsIdPolls(ctx, id, params)
	return err
}

// GetCampaignsIdRewards converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampaignsIdRewards(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCampaignsIdRewardsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCampaignsIdRewards(ctx, id, params)
	return err
}

// GetCampaignsIdSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampaignsIdSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCampaignsIdScheduleParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCampaignsIdSchedule(ctx, id, params)
	return err
}

// GetCampaignsIdSupportingCampaigns converts echo context to params.
func (w *ServerInterfaceWrapper) GetCampaignsIdSupportingCampaigns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCampaignsIdSupportingCampaignsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCampaignsIdSupportingCampaigns(ctx, id, params)
	return err
}

// GetCausesId converts echo context to params.
func (w *ServerInterfaceWrapper) GetCausesId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCausesId(ctx, id)
	return err
}

// GetCausesIdCampaigns converts echo context to params.
func (w *ServerInterfaceWrapper) GetCausesIdCampaigns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCausesIdCampaignsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCausesIdCampaigns(ctx, id, params)
	return err
}

// GetCausesIdFundraisingEvents converts echo context to params.
func (w *ServerInterfaceWrapper) GetCausesIdFundraisingEvents(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCausesIdFundraisingEventsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCausesIdFundraisingEvents(ctx, id, params)
	return err
}

// GetCausesIdLeaderboards converts echo context to params.
func (w *ServerInterfaceWrapper) GetCausesIdLeaderboards(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCausesIdLeaderboards(ctx, id)
	return err
}

// GetCausesIdPermissions converts echo context to params.
func (w *ServerInterfaceWrapper) GetCausesIdPermissions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCausesIdPermissions(ctx, id)
	return err
}

// GetCausesIdVisibilityOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetCausesIdVisibilityOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCausesIdVisibilityOptionsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCausesIdVisibilityOptions(ctx, id, params)
	return err
}

// PatchCausesIdVisibilityOptions converts echo context to params.
func (w *ServerInterfaceWrapper) PatchCausesIdVisibilityOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchCausesIdVisibilityOptions(ctx, id)
	return err
}

// GetFundraisingEvents converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEvents(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEvents(ctx, params)
	return err
}

// GetFundraisingEventsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsId(ctx, id)
	return err
}

// GetFundraisingEventsIdCampaigns converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsIdCampaigns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsIdCampaignsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsIdCampaigns(ctx, id, params)
	return err
}

// GetFundraisingEventsIdIncentives converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsIdIncentives(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsIdIncentivesParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsIdIncentives(ctx, id, params)
	return err
}

// GetFundraisingEventsIdLeaderboards converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsIdLeaderboards(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsIdLeaderboardsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsIdLeaderboards(ctx, id, params)
	return err
}

// GetFundraisingEventsIdRegistrationFields converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsIdRegistrationFields(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsIdRegistrationFieldsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsIdRegistrationFields(ctx, id, params)
	return err
}

// GetFundraisingEventsIdRegistrations converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsIdRegistrations(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsIdRegistrationsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsIdRegistrations(ctx, id, params)
	return err
}

// GetFundraisingEventsIdSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsIdSchedule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsIdScheduleParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsIdSchedule(ctx, id, params)
	return err
}

// GetFundraisingEventsIdVisibilityOptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetFundraisingEventsIdVisibilityOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFundraisingEventsIdVisibilityOptionsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFundraisingEventsIdVisibilityOptions(ctx, id, params)
	return err
}

// GetTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetTeams(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTeams(ctx, params)
	return err
}

// GetTeamsId converts echo context to params.
func (w *ServerInterfaceWrapper) GetTeamsId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTeamsId(ctx, id)
	return err
}

// GetTeamsIdCampaigns converts echo context to params.
func (w *ServerInterfaceWrapper) GetTeamsIdCampaigns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamsIdCampaignsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTeamsIdCampaigns(ctx, id, params)
	return err
}

// GetTeamsIdCampaignsCid converts echo context to params.
func (w *ServerInterfaceWrapper) GetTeamsIdCampaignsCid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "cid" -------------
	var cid int

	err = runtime.BindStyledParameterWithLocation("simple", false, "cid", runtime.ParamLocationPath, ctx.Param("cid"), &cid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTeamsIdCampaignsCid(ctx, id, cid)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx)
	return err
}

// GetUsersId converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersId(ctx, id)
	return err
}

// GetUsersIdCampaigns converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersIdCampaigns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersIdCampaignsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersIdCampaigns(ctx, id, params)
	return err
}

// GetUsersIdCampaignsCid converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersIdCampaignsCid(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Path parameter "cid" -------------
	var cid int

	err = runtime.BindStyledParameterWithLocation("simple", false, "cid", runtime.ParamLocationPath, ctx.Param("cid"), &cid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter cid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersIdCampaignsCid(ctx, id, cid)
	return err
}

// GetUsersIdOwnedTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersIdOwnedTeams(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersIdOwnedTeamsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersIdOwnedTeams(ctx, id, params)
	return err
}

// GetUsersIdTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsersIdTeams(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id int

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersIdTeamsParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsersIdTeams(ctx, id, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/campaigns/:id", wrapper.GetCampaignsId)
	router.GET(baseURL+"/campaigns/:id/challenges", wrapper.GetCampaignsIdChallenges)
	router.GET(baseURL+"/campaigns/:id/donations", wrapper.GetCampaignsIdDonations)
	router.GET(baseURL+"/campaigns/:id/polls", wrapper.GetCampaignsIdPolls)
	router.GET(baseURL+"/campaigns/:id/rewards", wrapper.GetCampaignsIdRewards)
	router.GET(baseURL+"/campaigns/:id/schedule", wrapper.GetCampaignsIdSchedule)
	router.GET(baseURL+"/campaigns/:id/supporting-campaigns", wrapper.GetCampaignsIdSupportingCampaigns)
	router.GET(baseURL+"/causes/:id", wrapper.GetCausesId)
	router.GET(baseURL+"/causes/:id/campaigns", wrapper.GetCausesIdCampaigns)
	router.GET(baseURL+"/causes/:id/fundraising-events", wrapper.GetCausesIdFundraisingEvents)
	router.GET(baseURL+"/causes/:id/leaderboards", wrapper.GetCausesIdLeaderboards)
	router.GET(baseURL+"/causes/:id/permissions", wrapper.GetCausesIdPermissions)
	router.GET(baseURL+"/causes/:id/visibility-options", wrapper.GetCausesIdVisibilityOptions)
	router.PATCH(baseURL+"/causes/:id/visibility-options", wrapper.PatchCausesIdVisibilityOptions)
	router.GET(baseURL+"/fundraising-events", wrapper.GetFundraisingEvents)
	router.GET(baseURL+"/fundraising-events/:id", wrapper.GetFundraisingEventsId)
	router.GET(baseURL+"/fundraising-events/:id/campaigns", wrapper.GetFundraisingEventsIdCampaigns)
	router.GET(baseURL+"/fundraising-events/:id/incentives", wrapper.GetFundraisingEventsIdIncentives)
	router.GET(baseURL+"/fundraising-events/:id/leaderboards", wrapper.GetFundraisingEventsIdLeaderboards)
	router.GET(baseURL+"/fundraising-events/:id/registration-fields", wrapper.GetFundraisingEventsIdRegistrationFields)
	router.GET(baseURL+"/fundraising-events/:id/registrations", wrapper.GetFundraisingEventsIdRegistrations)
	router.GET(baseURL+"/fundraising-events/:id/schedule", wrapper.GetFundraisingEventsIdSchedule)
	router.GET(baseURL+"/fundraising-events/:id/visibility-options", wrapper.GetFundraisingEventsIdVisibilityOptions)
	router.GET(baseURL+"/teams", wrapper.GetTeams)
	router.GET(baseURL+"/teams/:id", wrapper.GetTeamsId)
	router.GET(baseURL+"/teams/:id/campaigns", wrapper.GetTeamsIdCampaigns)
	router.GET(baseURL+"/teams/:id/campaigns/:cid", wrapper.GetTeamsIdCampaignsCid)
	router.GET(baseURL+"/user", wrapper.GetUser)
	router.GET(baseURL+"/users/:id", wrapper.GetUsersId)
	router.GET(baseURL+"/users/:id/campaigns", wrapper.GetUsersIdCampaigns)
	router.GET(baseURL+"/users/:id/campaigns/:cid", wrapper.GetUsersIdCampaignsCid)
	router.GET(baseURL+"/users/:id/owned-teams", wrapper.GetUsersIdOwnedTeams)
	router.GET(baseURL+"/users/:id/teams", wrapper.GetUsersIdTeams)

}
