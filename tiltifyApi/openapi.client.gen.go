// Package tiltifyApi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package tiltifyApi

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetCampaignsId request
	GetCampaignsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdChallenges request
	GetCampaignsIdChallenges(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdDonations request
	GetCampaignsIdDonations(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdPolls request
	GetCampaignsIdPolls(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdRewards request
	GetCampaignsIdRewards(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdSchedule request
	GetCampaignsIdSchedule(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCampaignsIdSupportingCampaigns request
	GetCampaignsIdSupportingCampaigns(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesId request
	GetCausesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdCampaigns request
	GetCausesIdCampaigns(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdFundraisingEvents request
	GetCausesIdFundraisingEvents(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdLeaderboards request
	GetCausesIdLeaderboards(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdPermissions request
	GetCausesIdPermissions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesIdVisibilityOptions request
	GetCausesIdVisibilityOptions(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchCausesIdVisibilityOptions request
	PatchCausesIdVisibilityOptions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCausesSlug request
	GetCausesSlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEvents request
	GetFundraisingEvents(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsId request
	GetFundraisingEventsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdCampaigns request
	GetFundraisingEventsIdCampaigns(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdIncentives request
	GetFundraisingEventsIdIncentives(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdLeaderboards request
	GetFundraisingEventsIdLeaderboards(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdRegistrationFields request
	GetFundraisingEventsIdRegistrationFields(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdRegistrations request
	GetFundraisingEventsIdRegistrations(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdSchedule request
	GetFundraisingEventsIdSchedule(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFundraisingEventsIdVisibilityOptions request
	GetFundraisingEventsIdVisibilityOptions(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsId request
	GetTeamsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsIdCampaigns request
	GetTeamsIdCampaigns(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsIdCampaignsCid request
	GetTeamsIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersId request
	GetUsersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdCampaigns request
	GetUsersIdCampaigns(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdCampaignsCid request
	GetUsersIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdOwnedTeams request
	GetUsersIdOwnedTeams(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersIdTeams request
	GetUsersIdTeams(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersSlug request
	GetUsersSlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetCampaignsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdChallenges(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdChallengesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdDonations(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdDonationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdPolls(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdPollsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdRewards(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdRewardsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdSchedule(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCampaignsIdSupportingCampaigns(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCampaignsIdSupportingCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdCampaigns(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdFundraisingEvents(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdFundraisingEventsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdLeaderboards(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdLeaderboardsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdPermissions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdPermissionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesIdVisibilityOptions(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesIdVisibilityOptionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchCausesIdVisibilityOptions(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchCausesIdVisibilityOptionsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCausesSlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCausesSlugRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEvents(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdCampaigns(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdIncentives(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdIncentivesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdLeaderboards(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdLeaderboardsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdRegistrationFields(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdRegistrationFieldsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdRegistrations(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdRegistrationsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdSchedule(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdScheduleRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFundraisingEventsIdVisibilityOptions(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFundraisingEventsIdVisibilityOptionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsIdCampaigns(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsIdCampaignsCidRequest(c.Server, id, cid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersId(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdCampaigns(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdCampaignsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdCampaignsCid(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdCampaignsCidRequest(c.Server, id, cid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdOwnedTeams(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdOwnedTeamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersIdTeams(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersIdTeamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersSlug(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersSlugRequest(c.Server, slug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetCampaignsIdRequest generates requests for GetCampaignsId
func NewGetCampaignsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdChallengesRequest generates requests for GetCampaignsIdChallenges
func NewGetCampaignsIdChallengesRequest(server string, id int, params *GetCampaignsIdChallengesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/challenges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdDonationsRequest generates requests for GetCampaignsIdDonations
func NewGetCampaignsIdDonationsRequest(server string, id int, params *GetCampaignsIdDonationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/donations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdPollsRequest generates requests for GetCampaignsIdPolls
func NewGetCampaignsIdPollsRequest(server string, id int, params *GetCampaignsIdPollsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/polls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdRewardsRequest generates requests for GetCampaignsIdRewards
func NewGetCampaignsIdRewardsRequest(server string, id int, params *GetCampaignsIdRewardsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/rewards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdScheduleRequest generates requests for GetCampaignsIdSchedule
func NewGetCampaignsIdScheduleRequest(server string, id int, params *GetCampaignsIdScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCampaignsIdSupportingCampaignsRequest generates requests for GetCampaignsIdSupportingCampaigns
func NewGetCampaignsIdSupportingCampaignsRequest(server string, id int, params *GetCampaignsIdSupportingCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/campaigns/%s/supporting-campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdRequest generates requests for GetCausesId
func NewGetCausesIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdCampaignsRequest generates requests for GetCausesIdCampaigns
func NewGetCausesIdCampaignsRequest(server string, id int, params *GetCausesIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdFundraisingEventsRequest generates requests for GetCausesIdFundraisingEvents
func NewGetCausesIdFundraisingEventsRequest(server string, id int, params *GetCausesIdFundraisingEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/fundraising-events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdLeaderboardsRequest generates requests for GetCausesIdLeaderboards
func NewGetCausesIdLeaderboardsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/leaderboards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdPermissionsRequest generates requests for GetCausesIdPermissions
func NewGetCausesIdPermissionsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesIdVisibilityOptionsRequest generates requests for GetCausesIdVisibilityOptions
func NewGetCausesIdVisibilityOptionsRequest(server string, id int, params *GetCausesIdVisibilityOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/visibility-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchCausesIdVisibilityOptionsRequest generates requests for PatchCausesIdVisibilityOptions
func NewPatchCausesIdVisibilityOptionsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s/visibility-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCausesSlugRequest generates requests for GetCausesSlug
func NewGetCausesSlugRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/causes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsRequest generates requests for GetFundraisingEvents
func NewGetFundraisingEventsRequest(server string, params *GetFundraisingEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdRequest generates requests for GetFundraisingEventsId
func NewGetFundraisingEventsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdCampaignsRequest generates requests for GetFundraisingEventsIdCampaigns
func NewGetFundraisingEventsIdCampaignsRequest(server string, id int, params *GetFundraisingEventsIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdIncentivesRequest generates requests for GetFundraisingEventsIdIncentives
func NewGetFundraisingEventsIdIncentivesRequest(server string, id int, params *GetFundraisingEventsIdIncentivesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/incentives", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdLeaderboardsRequest generates requests for GetFundraisingEventsIdLeaderboards
func NewGetFundraisingEventsIdLeaderboardsRequest(server string, id int, params *GetFundraisingEventsIdLeaderboardsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/leaderboards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdRegistrationFieldsRequest generates requests for GetFundraisingEventsIdRegistrationFields
func NewGetFundraisingEventsIdRegistrationFieldsRequest(server string, id int, params *GetFundraisingEventsIdRegistrationFieldsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/registration-fields", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdRegistrationsRequest generates requests for GetFundraisingEventsIdRegistrations
func NewGetFundraisingEventsIdRegistrationsRequest(server string, id int, params *GetFundraisingEventsIdRegistrationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/registrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdScheduleRequest generates requests for GetFundraisingEventsIdSchedule
func NewGetFundraisingEventsIdScheduleRequest(server string, id int, params *GetFundraisingEventsIdScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFundraisingEventsIdVisibilityOptionsRequest generates requests for GetFundraisingEventsIdVisibilityOptions
func NewGetFundraisingEventsIdVisibilityOptionsRequest(server string, id int, params *GetFundraisingEventsIdVisibilityOptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fundraising-events/%s/visibility-options", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsIdRequest generates requests for GetTeamsId
func NewGetTeamsIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsIdCampaignsRequest generates requests for GetTeamsIdCampaigns
func NewGetTeamsIdCampaignsRequest(server string, id int, params *GetTeamsIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsIdCampaignsCidRequest generates requests for GetTeamsIdCampaignsCid
func NewGetTeamsIdCampaignsCidRequest(server string, id int, cid int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cid", runtime.ParamLocationPath, cid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/campaigns/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdRequest generates requests for GetUsersId
func NewGetUsersIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdCampaignsRequest generates requests for GetUsersIdCampaigns
func NewGetUsersIdCampaignsRequest(server string, id int, params *GetUsersIdCampaignsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/campaigns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdCampaignsCidRequest generates requests for GetUsersIdCampaignsCid
func NewGetUsersIdCampaignsCidRequest(server string, id int, cid int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cid", runtime.ParamLocationPath, cid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/campaigns/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdOwnedTeamsRequest generates requests for GetUsersIdOwnedTeams
func NewGetUsersIdOwnedTeamsRequest(server string, id int, params *GetUsersIdOwnedTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/owned-teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersIdTeamsRequest generates requests for GetUsersIdTeams
func NewGetUsersIdTeamsRequest(server string, id int, params *GetUsersIdTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersSlugRequest generates requests for GetUsersSlug
func NewGetUsersSlugRequest(server string, slug string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "slug", runtime.ParamLocationPath, slug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetCampaignsId request
	GetCampaignsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCampaignsIdResponse, error)

	// GetCampaignsIdChallenges request
	GetCampaignsIdChallengesWithResponse(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdChallengesResponse, error)

	// GetCampaignsIdDonations request
	GetCampaignsIdDonationsWithResponse(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdDonationsResponse, error)

	// GetCampaignsIdPolls request
	GetCampaignsIdPollsWithResponse(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdPollsResponse, error)

	// GetCampaignsIdRewards request
	GetCampaignsIdRewardsWithResponse(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdRewardsResponse, error)

	// GetCampaignsIdSchedule request
	GetCampaignsIdScheduleWithResponse(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdScheduleResponse, error)

	// GetCampaignsIdSupportingCampaigns request
	GetCampaignsIdSupportingCampaignsWithResponse(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdSupportingCampaignsResponse, error)

	// GetCausesId request
	GetCausesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdResponse, error)

	// GetCausesIdCampaigns request
	GetCausesIdCampaignsWithResponse(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetCausesIdCampaignsResponse, error)

	// GetCausesIdFundraisingEvents request
	GetCausesIdFundraisingEventsWithResponse(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetCausesIdFundraisingEventsResponse, error)

	// GetCausesIdLeaderboards request
	GetCausesIdLeaderboardsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdLeaderboardsResponse, error)

	// GetCausesIdPermissions request
	GetCausesIdPermissionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdPermissionsResponse, error)

	// GetCausesIdVisibilityOptions request
	GetCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetCausesIdVisibilityOptionsResponse, error)

	// PatchCausesIdVisibilityOptions request
	PatchCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*PatchCausesIdVisibilityOptionsResponse, error)

	// GetCausesSlug request
	GetCausesSlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetCausesSlugResponse, error)

	// GetFundraisingEvents request
	GetFundraisingEventsWithResponse(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsResponse, error)

	// GetFundraisingEventsId request
	GetFundraisingEventsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdResponse, error)

	// GetFundraisingEventsIdCampaigns request
	GetFundraisingEventsIdCampaignsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdCampaignsResponse, error)

	// GetFundraisingEventsIdIncentives request
	GetFundraisingEventsIdIncentivesWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdIncentivesResponse, error)

	// GetFundraisingEventsIdLeaderboards request
	GetFundraisingEventsIdLeaderboardsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdLeaderboardsResponse, error)

	// GetFundraisingEventsIdRegistrationFields request
	GetFundraisingEventsIdRegistrationFieldsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationFieldsResponse, error)

	// GetFundraisingEventsIdRegistrations request
	GetFundraisingEventsIdRegistrationsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationsResponse, error)

	// GetFundraisingEventsIdSchedule request
	GetFundraisingEventsIdScheduleWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdScheduleResponse, error)

	// GetFundraisingEventsIdVisibilityOptions request
	GetFundraisingEventsIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdVisibilityOptionsResponse, error)

	// GetTeams request
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// GetTeamsId request
	GetTeamsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamsIdResponse, error)

	// GetTeamsIdCampaigns request
	GetTeamsIdCampaignsWithResponse(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsResponse, error)

	// GetTeamsIdCampaignsCid request
	GetTeamsIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsCidResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// GetUsersId request
	GetUsersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error)

	// GetUsersIdCampaigns request
	GetUsersIdCampaignsWithResponse(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsResponse, error)

	// GetUsersIdCampaignsCid request
	GetUsersIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsCidResponse, error)

	// GetUsersIdOwnedTeams request
	GetUsersIdOwnedTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdOwnedTeamsResponse, error)

	// GetUsersIdTeams request
	GetUsersIdTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdTeamsResponse, error)

	// GetUsersSlug request
	GetUsersSlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetUsersSlugResponse, error)
}

type GetCampaignsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *CampaignsId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdChallengesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]CampaignsIdChallenges `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdChallengesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdChallengesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdDonationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]CampaignsIdDonations `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdDonationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdDonationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdPollsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]CampaignsIdPolls `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdPollsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdPollsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdRewardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *interface{} `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdRewardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdRewardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *CampaignsIdSchedule `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCampaignsIdSupportingCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]CampaignsIdSupportingCampaigns `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCampaignsIdSupportingCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCampaignsIdSupportingCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *CausesId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]CausesIdCampaigns `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdFundraisingEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]CausesIdFundraisingEvents `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdFundraisingEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdFundraisingEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdLeaderboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]CausesIdLeaderboards `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdLeaderboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdLeaderboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *CausesIdPermissions `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesIdVisibilityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *CausesIdVisibilityOptions `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesIdVisibilityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesIdVisibilityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchCausesIdVisibilityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *CausesIdVisibilityOptions `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r PatchCausesIdVisibilityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchCausesIdVisibilityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCausesSlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *CausesId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetCausesSlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCausesSlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]FundraisingEvents `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *FundraisingEventsId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]FundraisingEventsIdCampaigns `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdIncentivesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]FundraisingEventsIdIncentives `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdIncentivesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdIncentivesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdLeaderboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *FundraisingEventsIdLeaderboards `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdLeaderboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdLeaderboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdRegistrationFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *FundraisingEventsIdRegistrationFields `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdRegistrationFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdRegistrationFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdRegistrationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]FundraisingEventsIdRegistrations `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdRegistrationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdRegistrationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]FundraisingEventsIdSchedule `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFundraisingEventsIdVisibilityOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *FundraisingEventsIdVisibilityOptions `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetFundraisingEventsIdVisibilityOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFundraisingEventsIdVisibilityOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]Teams `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *TeamsId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]TeamsIdCampaigns `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsIdCampaignsCidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *TeamsIdCampaignsId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetTeamsIdCampaignsCidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsIdCampaignsCidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *User `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *UsersId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsersIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdCampaignsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]UsersIdCampaigns `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdCampaignsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdCampaignsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdCampaignsCidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *UsersIdCampaignsId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdCampaignsCidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdCampaignsCidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdOwnedTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]UsersIdOwnedTeams `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdOwnedTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdOwnedTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersIdTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]UsersIdTeams `json:"data,omitempty"`

		// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
		Links *Pagination `json:"links,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersIdTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersIdTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersSlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *UsersId `json:"data,omitempty"`

		// This is the HTTP status code that is also sent with the request
		Meta *Meta `json:"meta,omitempty"`
	}
	JSON400 *Error
	JSON401 *Error
	JSON403 *Error
	JSON404 *Error
	JSON422 *Error
	JSON5XX *Error
}

// Status returns HTTPResponse.Status
func (r GetUsersSlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersSlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetCampaignsIdWithResponse request returning *GetCampaignsIdResponse
func (c *ClientWithResponses) GetCampaignsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCampaignsIdResponse, error) {
	rsp, err := c.GetCampaignsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdResponse(rsp)
}

// GetCampaignsIdChallengesWithResponse request returning *GetCampaignsIdChallengesResponse
func (c *ClientWithResponses) GetCampaignsIdChallengesWithResponse(ctx context.Context, id int, params *GetCampaignsIdChallengesParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdChallengesResponse, error) {
	rsp, err := c.GetCampaignsIdChallenges(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdChallengesResponse(rsp)
}

// GetCampaignsIdDonationsWithResponse request returning *GetCampaignsIdDonationsResponse
func (c *ClientWithResponses) GetCampaignsIdDonationsWithResponse(ctx context.Context, id int, params *GetCampaignsIdDonationsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdDonationsResponse, error) {
	rsp, err := c.GetCampaignsIdDonations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdDonationsResponse(rsp)
}

// GetCampaignsIdPollsWithResponse request returning *GetCampaignsIdPollsResponse
func (c *ClientWithResponses) GetCampaignsIdPollsWithResponse(ctx context.Context, id int, params *GetCampaignsIdPollsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdPollsResponse, error) {
	rsp, err := c.GetCampaignsIdPolls(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdPollsResponse(rsp)
}

// GetCampaignsIdRewardsWithResponse request returning *GetCampaignsIdRewardsResponse
func (c *ClientWithResponses) GetCampaignsIdRewardsWithResponse(ctx context.Context, id int, params *GetCampaignsIdRewardsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdRewardsResponse, error) {
	rsp, err := c.GetCampaignsIdRewards(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdRewardsResponse(rsp)
}

// GetCampaignsIdScheduleWithResponse request returning *GetCampaignsIdScheduleResponse
func (c *ClientWithResponses) GetCampaignsIdScheduleWithResponse(ctx context.Context, id int, params *GetCampaignsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdScheduleResponse, error) {
	rsp, err := c.GetCampaignsIdSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdScheduleResponse(rsp)
}

// GetCampaignsIdSupportingCampaignsWithResponse request returning *GetCampaignsIdSupportingCampaignsResponse
func (c *ClientWithResponses) GetCampaignsIdSupportingCampaignsWithResponse(ctx context.Context, id int, params *GetCampaignsIdSupportingCampaignsParams, reqEditors ...RequestEditorFn) (*GetCampaignsIdSupportingCampaignsResponse, error) {
	rsp, err := c.GetCampaignsIdSupportingCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCampaignsIdSupportingCampaignsResponse(rsp)
}

// GetCausesIdWithResponse request returning *GetCausesIdResponse
func (c *ClientWithResponses) GetCausesIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdResponse, error) {
	rsp, err := c.GetCausesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdResponse(rsp)
}

// GetCausesIdCampaignsWithResponse request returning *GetCausesIdCampaignsResponse
func (c *ClientWithResponses) GetCausesIdCampaignsWithResponse(ctx context.Context, id int, params *GetCausesIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetCausesIdCampaignsResponse, error) {
	rsp, err := c.GetCausesIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdCampaignsResponse(rsp)
}

// GetCausesIdFundraisingEventsWithResponse request returning *GetCausesIdFundraisingEventsResponse
func (c *ClientWithResponses) GetCausesIdFundraisingEventsWithResponse(ctx context.Context, id int, params *GetCausesIdFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetCausesIdFundraisingEventsResponse, error) {
	rsp, err := c.GetCausesIdFundraisingEvents(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdFundraisingEventsResponse(rsp)
}

// GetCausesIdLeaderboardsWithResponse request returning *GetCausesIdLeaderboardsResponse
func (c *ClientWithResponses) GetCausesIdLeaderboardsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdLeaderboardsResponse, error) {
	rsp, err := c.GetCausesIdLeaderboards(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdLeaderboardsResponse(rsp)
}

// GetCausesIdPermissionsWithResponse request returning *GetCausesIdPermissionsResponse
func (c *ClientWithResponses) GetCausesIdPermissionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCausesIdPermissionsResponse, error) {
	rsp, err := c.GetCausesIdPermissions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdPermissionsResponse(rsp)
}

// GetCausesIdVisibilityOptionsWithResponse request returning *GetCausesIdVisibilityOptionsResponse
func (c *ClientWithResponses) GetCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetCausesIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetCausesIdVisibilityOptionsResponse, error) {
	rsp, err := c.GetCausesIdVisibilityOptions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesIdVisibilityOptionsResponse(rsp)
}

// PatchCausesIdVisibilityOptionsWithResponse request returning *PatchCausesIdVisibilityOptionsResponse
func (c *ClientWithResponses) PatchCausesIdVisibilityOptionsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*PatchCausesIdVisibilityOptionsResponse, error) {
	rsp, err := c.PatchCausesIdVisibilityOptions(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchCausesIdVisibilityOptionsResponse(rsp)
}

// GetCausesSlugWithResponse request returning *GetCausesSlugResponse
func (c *ClientWithResponses) GetCausesSlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetCausesSlugResponse, error) {
	rsp, err := c.GetCausesSlug(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCausesSlugResponse(rsp)
}

// GetFundraisingEventsWithResponse request returning *GetFundraisingEventsResponse
func (c *ClientWithResponses) GetFundraisingEventsWithResponse(ctx context.Context, params *GetFundraisingEventsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsResponse, error) {
	rsp, err := c.GetFundraisingEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsResponse(rsp)
}

// GetFundraisingEventsIdWithResponse request returning *GetFundraisingEventsIdResponse
func (c *ClientWithResponses) GetFundraisingEventsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdResponse, error) {
	rsp, err := c.GetFundraisingEventsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdResponse(rsp)
}

// GetFundraisingEventsIdCampaignsWithResponse request returning *GetFundraisingEventsIdCampaignsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdCampaignsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdCampaignsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdCampaignsResponse(rsp)
}

// GetFundraisingEventsIdIncentivesWithResponse request returning *GetFundraisingEventsIdIncentivesResponse
func (c *ClientWithResponses) GetFundraisingEventsIdIncentivesWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdIncentivesParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdIncentivesResponse, error) {
	rsp, err := c.GetFundraisingEventsIdIncentives(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdIncentivesResponse(rsp)
}

// GetFundraisingEventsIdLeaderboardsWithResponse request returning *GetFundraisingEventsIdLeaderboardsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdLeaderboardsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdLeaderboardsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdLeaderboardsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdLeaderboards(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdLeaderboardsResponse(rsp)
}

// GetFundraisingEventsIdRegistrationFieldsWithResponse request returning *GetFundraisingEventsIdRegistrationFieldsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdRegistrationFieldsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationFieldsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationFieldsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdRegistrationFields(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdRegistrationFieldsResponse(rsp)
}

// GetFundraisingEventsIdRegistrationsWithResponse request returning *GetFundraisingEventsIdRegistrationsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdRegistrationsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdRegistrationsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdRegistrationsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdRegistrations(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdRegistrationsResponse(rsp)
}

// GetFundraisingEventsIdScheduleWithResponse request returning *GetFundraisingEventsIdScheduleResponse
func (c *ClientWithResponses) GetFundraisingEventsIdScheduleWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdScheduleParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdScheduleResponse, error) {
	rsp, err := c.GetFundraisingEventsIdSchedule(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdScheduleResponse(rsp)
}

// GetFundraisingEventsIdVisibilityOptionsWithResponse request returning *GetFundraisingEventsIdVisibilityOptionsResponse
func (c *ClientWithResponses) GetFundraisingEventsIdVisibilityOptionsWithResponse(ctx context.Context, id int, params *GetFundraisingEventsIdVisibilityOptionsParams, reqEditors ...RequestEditorFn) (*GetFundraisingEventsIdVisibilityOptionsResponse, error) {
	rsp, err := c.GetFundraisingEventsIdVisibilityOptions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFundraisingEventsIdVisibilityOptionsResponse(rsp)
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error) {
	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsResponse(rsp)
}

// GetTeamsIdWithResponse request returning *GetTeamsIdResponse
func (c *ClientWithResponses) GetTeamsIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetTeamsIdResponse, error) {
	rsp, err := c.GetTeamsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdResponse(rsp)
}

// GetTeamsIdCampaignsWithResponse request returning *GetTeamsIdCampaignsResponse
func (c *ClientWithResponses) GetTeamsIdCampaignsWithResponse(ctx context.Context, id int, params *GetTeamsIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsResponse, error) {
	rsp, err := c.GetTeamsIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdCampaignsResponse(rsp)
}

// GetTeamsIdCampaignsCidWithResponse request returning *GetTeamsIdCampaignsCidResponse
func (c *ClientWithResponses) GetTeamsIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetTeamsIdCampaignsCidResponse, error) {
	rsp, err := c.GetTeamsIdCampaignsCid(ctx, id, cid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsIdCampaignsCidResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// GetUsersIdWithResponse request returning *GetUsersIdResponse
func (c *ClientWithResponses) GetUsersIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUsersIdResponse, error) {
	rsp, err := c.GetUsersId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdResponse(rsp)
}

// GetUsersIdCampaignsWithResponse request returning *GetUsersIdCampaignsResponse
func (c *ClientWithResponses) GetUsersIdCampaignsWithResponse(ctx context.Context, id int, params *GetUsersIdCampaignsParams, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsResponse, error) {
	rsp, err := c.GetUsersIdCampaigns(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdCampaignsResponse(rsp)
}

// GetUsersIdCampaignsCidWithResponse request returning *GetUsersIdCampaignsCidResponse
func (c *ClientWithResponses) GetUsersIdCampaignsCidWithResponse(ctx context.Context, id int, cid int, reqEditors ...RequestEditorFn) (*GetUsersIdCampaignsCidResponse, error) {
	rsp, err := c.GetUsersIdCampaignsCid(ctx, id, cid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdCampaignsCidResponse(rsp)
}

// GetUsersIdOwnedTeamsWithResponse request returning *GetUsersIdOwnedTeamsResponse
func (c *ClientWithResponses) GetUsersIdOwnedTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdOwnedTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdOwnedTeamsResponse, error) {
	rsp, err := c.GetUsersIdOwnedTeams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdOwnedTeamsResponse(rsp)
}

// GetUsersIdTeamsWithResponse request returning *GetUsersIdTeamsResponse
func (c *ClientWithResponses) GetUsersIdTeamsWithResponse(ctx context.Context, id int, params *GetUsersIdTeamsParams, reqEditors ...RequestEditorFn) (*GetUsersIdTeamsResponse, error) {
	rsp, err := c.GetUsersIdTeams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersIdTeamsResponse(rsp)
}

// GetUsersSlugWithResponse request returning *GetUsersSlugResponse
func (c *ClientWithResponses) GetUsersSlugWithResponse(ctx context.Context, slug string, reqEditors ...RequestEditorFn) (*GetUsersSlugResponse, error) {
	rsp, err := c.GetUsersSlug(ctx, slug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersSlugResponse(rsp)
}

// ParseGetCampaignsIdResponse parses an HTTP response from a GetCampaignsIdWithResponse call
func ParseGetCampaignsIdResponse(rsp *http.Response) (*GetCampaignsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *CampaignsId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdChallengesResponse parses an HTTP response from a GetCampaignsIdChallengesWithResponse call
func ParseGetCampaignsIdChallengesResponse(rsp *http.Response) (*GetCampaignsIdChallengesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdChallengesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]CampaignsIdChallenges `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdDonationsResponse parses an HTTP response from a GetCampaignsIdDonationsWithResponse call
func ParseGetCampaignsIdDonationsResponse(rsp *http.Response) (*GetCampaignsIdDonationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdDonationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]CampaignsIdDonations `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdPollsResponse parses an HTTP response from a GetCampaignsIdPollsWithResponse call
func ParseGetCampaignsIdPollsResponse(rsp *http.Response) (*GetCampaignsIdPollsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdPollsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]CampaignsIdPolls `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdRewardsResponse parses an HTTP response from a GetCampaignsIdRewardsWithResponse call
func ParseGetCampaignsIdRewardsResponse(rsp *http.Response) (*GetCampaignsIdRewardsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdRewardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *interface{} `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdScheduleResponse parses an HTTP response from a GetCampaignsIdScheduleWithResponse call
func ParseGetCampaignsIdScheduleResponse(rsp *http.Response) (*GetCampaignsIdScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *CampaignsIdSchedule `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCampaignsIdSupportingCampaignsResponse parses an HTTP response from a GetCampaignsIdSupportingCampaignsWithResponse call
func ParseGetCampaignsIdSupportingCampaignsResponse(rsp *http.Response) (*GetCampaignsIdSupportingCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCampaignsIdSupportingCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]CampaignsIdSupportingCampaigns `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdResponse parses an HTTP response from a GetCausesIdWithResponse call
func ParseGetCausesIdResponse(rsp *http.Response) (*GetCausesIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *CausesId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdCampaignsResponse parses an HTTP response from a GetCausesIdCampaignsWithResponse call
func ParseGetCausesIdCampaignsResponse(rsp *http.Response) (*GetCausesIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]CausesIdCampaigns `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdFundraisingEventsResponse parses an HTTP response from a GetCausesIdFundraisingEventsWithResponse call
func ParseGetCausesIdFundraisingEventsResponse(rsp *http.Response) (*GetCausesIdFundraisingEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdFundraisingEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]CausesIdFundraisingEvents `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdLeaderboardsResponse parses an HTTP response from a GetCausesIdLeaderboardsWithResponse call
func ParseGetCausesIdLeaderboardsResponse(rsp *http.Response) (*GetCausesIdLeaderboardsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdLeaderboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]CausesIdLeaderboards `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdPermissionsResponse parses an HTTP response from a GetCausesIdPermissionsWithResponse call
func ParseGetCausesIdPermissionsResponse(rsp *http.Response) (*GetCausesIdPermissionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *CausesIdPermissions `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesIdVisibilityOptionsResponse parses an HTTP response from a GetCausesIdVisibilityOptionsWithResponse call
func ParseGetCausesIdVisibilityOptionsResponse(rsp *http.Response) (*GetCausesIdVisibilityOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesIdVisibilityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *CausesIdVisibilityOptions `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParsePatchCausesIdVisibilityOptionsResponse parses an HTTP response from a PatchCausesIdVisibilityOptionsWithResponse call
func ParsePatchCausesIdVisibilityOptionsResponse(rsp *http.Response) (*PatchCausesIdVisibilityOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchCausesIdVisibilityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *CausesIdVisibilityOptions `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetCausesSlugResponse parses an HTTP response from a GetCausesSlugWithResponse call
func ParseGetCausesSlugResponse(rsp *http.Response) (*GetCausesSlugResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCausesSlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *CausesId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsResponse parses an HTTP response from a GetFundraisingEventsWithResponse call
func ParseGetFundraisingEventsResponse(rsp *http.Response) (*GetFundraisingEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]FundraisingEvents `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdResponse parses an HTTP response from a GetFundraisingEventsIdWithResponse call
func ParseGetFundraisingEventsIdResponse(rsp *http.Response) (*GetFundraisingEventsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *FundraisingEventsId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdCampaignsResponse parses an HTTP response from a GetFundraisingEventsIdCampaignsWithResponse call
func ParseGetFundraisingEventsIdCampaignsResponse(rsp *http.Response) (*GetFundraisingEventsIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]FundraisingEventsIdCampaigns `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdIncentivesResponse parses an HTTP response from a GetFundraisingEventsIdIncentivesWithResponse call
func ParseGetFundraisingEventsIdIncentivesResponse(rsp *http.Response) (*GetFundraisingEventsIdIncentivesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdIncentivesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]FundraisingEventsIdIncentives `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdLeaderboardsResponse parses an HTTP response from a GetFundraisingEventsIdLeaderboardsWithResponse call
func ParseGetFundraisingEventsIdLeaderboardsResponse(rsp *http.Response) (*GetFundraisingEventsIdLeaderboardsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdLeaderboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *FundraisingEventsIdLeaderboards `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdRegistrationFieldsResponse parses an HTTP response from a GetFundraisingEventsIdRegistrationFieldsWithResponse call
func ParseGetFundraisingEventsIdRegistrationFieldsResponse(rsp *http.Response) (*GetFundraisingEventsIdRegistrationFieldsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdRegistrationFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *FundraisingEventsIdRegistrationFields `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdRegistrationsResponse parses an HTTP response from a GetFundraisingEventsIdRegistrationsWithResponse call
func ParseGetFundraisingEventsIdRegistrationsResponse(rsp *http.Response) (*GetFundraisingEventsIdRegistrationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdRegistrationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]FundraisingEventsIdRegistrations `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdScheduleResponse parses an HTTP response from a GetFundraisingEventsIdScheduleWithResponse call
func ParseGetFundraisingEventsIdScheduleResponse(rsp *http.Response) (*GetFundraisingEventsIdScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]FundraisingEventsIdSchedule `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetFundraisingEventsIdVisibilityOptionsResponse parses an HTTP response from a GetFundraisingEventsIdVisibilityOptionsWithResponse call
func ParseGetFundraisingEventsIdVisibilityOptionsResponse(rsp *http.Response) (*GetFundraisingEventsIdVisibilityOptionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFundraisingEventsIdVisibilityOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *FundraisingEventsIdVisibilityOptions `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]Teams `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsIdResponse parses an HTTP response from a GetTeamsIdWithResponse call
func ParseGetTeamsIdResponse(rsp *http.Response) (*GetTeamsIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *TeamsId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsIdCampaignsResponse parses an HTTP response from a GetTeamsIdCampaignsWithResponse call
func ParseGetTeamsIdCampaignsResponse(rsp *http.Response) (*GetTeamsIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]TeamsIdCampaigns `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetTeamsIdCampaignsCidResponse parses an HTTP response from a GetTeamsIdCampaignsCidWithResponse call
func ParseGetTeamsIdCampaignsCidResponse(rsp *http.Response) (*GetTeamsIdCampaignsCidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsIdCampaignsCidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *TeamsIdCampaignsId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *User `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdResponse parses an HTTP response from a GetUsersIdWithResponse call
func ParseGetUsersIdResponse(rsp *http.Response) (*GetUsersIdResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *UsersId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersIdCampaignsResponse parses an HTTP response from a GetUsersIdCampaignsWithResponse call
func ParseGetUsersIdCampaignsResponse(rsp *http.Response) (*GetUsersIdCampaignsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdCampaignsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]UsersIdCampaigns `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdCampaignsCidResponse parses an HTTP response from a GetUsersIdCampaignsCidWithResponse call
func ParseGetUsersIdCampaignsCidResponse(rsp *http.Response) (*GetUsersIdCampaignsCidResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdCampaignsCidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *UsersIdCampaignsId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdOwnedTeamsResponse parses an HTTP response from a GetUsersIdOwnedTeamsWithResponse call
func ParseGetUsersIdOwnedTeamsResponse(rsp *http.Response) (*GetUsersIdOwnedTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdOwnedTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]UsersIdOwnedTeams `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersIdTeamsResponse parses an HTTP response from a GetUsersIdTeamsWithResponse call
func ParseGetUsersIdTeamsResponse(rsp *http.Response) (*GetUsersIdTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersIdTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]UsersIdTeams `json:"data,omitempty"`

			// We use cursor based pagination for our donations and this information is embeded in the response under the links key. You will find a prev and next link that point to the next pages of the paginated response. You may submit an optional count field of up to 100.
			Links *Pagination `json:"links,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}

// ParseGetUsersSlugResponse parses an HTTP response from a GetUsersSlugWithResponse call
func ParseGetUsersSlugResponse(rsp *http.Response) (*GetUsersSlugResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersSlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *UsersId `json:"data,omitempty"`

			// This is the HTTP status code that is also sent with the request
			Meta *Meta `json:"meta,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 5:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON5XX = &dest

	}

	return response, nil
}
